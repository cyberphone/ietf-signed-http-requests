<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.129b" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />

    <link rel="icon" href="" type="image/png" />
    <link rel="shortcut icon" href="" type="image/png" />
    <title>draft-rundgren-signed-http-requests-2.txt - Signed HTTP Requests (SHREQ)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo "
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>

<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Network Working Group                                        A. Rundgren
Internet-Draft                                               Independent
Intended status: Standards Track                       February 23, 2019
Expires: August 27, 2019


                      <span class="h1">Signed HTTP Requests (SHREQ)</span>
                 <span class="h1">draft-rundgren-signed-http-requests-00</span>

Abstract

   The SHREQ specification describes how the JSON Web Signature (JWS)
   specification combined with the JSON Canonicalization Scheme (JCS),
   can be utilized to support HTTP based applications needing digitally
   signed requests.  SHREQ is specifically tailored for Web applications
   using JSON as data interchange format.  However, there is also a
   SHREQ scheme for HTTP requests that do not have a body ("payload")
   like GET.  SHREQ was designed to be agnostic with respect to REST
   concepts versus traditional GET/POST schemes.

   The intended audiences of this document are Web tool vendors, as well
   as designers of secure Web applications.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of <a href="http://tools.ietf.org/html//bcp78">BCP 78</a> and <a href="http://tools.ietf.org/html//bcp79">BCP 79</a>.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at <a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a>.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on August 27, 2019.

Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="http://tools.ietf.org/html//bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of



<span class="grey">Rundgren                 Expires August 27, 2019                [Page 1]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  Determining Request Type  . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-4">4</a>.  Processing of JSON Based Requests . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-4.1">4.1</a>.  Request Creation  . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-4.2">4.2</a>.  Request Validation  . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
   <a href="#section-5">5</a>.  Processing of URI Based Requests  . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-5.1">5.1</a>.  Request Creation  . . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-5.2">5.2</a>.  Request Validation  . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-6">6</a>.  Common Operations . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-6.1">6.1</a>.  Create Signable JSON Data . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-6.2">6.2</a>.  Create Signable URI Data  . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-6.3">6.3</a>.  Create HTTP Header Digest . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-6.4">6.4</a>.  Create JWS Protected Header . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-6.5">6.5</a>.  Create JWS String . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-6.6">6.6</a>.  Decode JWS String . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-6.7">6.7</a>.  Normalize Target URI  . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-6.8">6.8</a>.  Validate HTTP Header Digest . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-6.9">6.9</a>.  Validate Signature  . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
   <a href="#section-7">7</a>.  Local Naming Conventions  . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-8">8</a>.  MIME Multipart Requests . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-9">9</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-10">10</a>. Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-11">11</a>. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-12">12</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-12.1">12.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-12.2">12.2</a>.  Informal References  . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#appendix-A">Appendix A</a>.  Other Signed HTTP Request Solutions  . . . . . . . .  <a href="#page-16">16</a>
     <a href="#appendix-A.1">A.1</a>.  Amazon Web Services . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#appendix-A.2">A.2</a>.  HTTP Signatures . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#appendix-A.3">A.3</a>.  Open Banking (UK) . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#appendix-A.4">A.4</a>.  Financial API . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   <a href="#appendix-B">Appendix B</a>.  Development Portal . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>








<span class="grey">Rundgren                 Expires August 27, 2019                [Page 2]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>.  Introduction</span>

   Currently there is no standard for digitally signing HTTP [<a href="http://tools.ietf.org/html//rfc7231" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content&quot;">RFC7231</a>]
   requests.  This has lead to the development of a multitude of more or
   less proprietary solutions (see <a href="#appendix-A">Appendix A</a>), typically building on
   using HTTP header data for holding security constructs, while JSON
   request data is provided in clear in the HTTP body.

   SHREQ is intended to provide a standardized alternative, including
   supporting the REST [<a href="#ref-REST" title="&quot;Architectural Styles and the Design of Network-based Software Architectures&quot;">REST</a>] concept.

   SHREQ builds on a common security model where the following elements
   of an HTTP request are signed:

   o  HTTP URI.

   o  HTTP method.

   o  HTTP body (if specified).

   o  Optional: Additional HTTP headers as defined by the actual
      ecosystem.

   One of the design goals was turning signed requests into self-
   contained objects.  To achieve this for HTTP requests having a JSON
   [<a href="http://tools.ietf.org/html//rfc8259" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC8259</a>] body (see <a href="#section-4">Section 4</a>), the request data also carries the
   signature.  This arrangement has certain implications:

   o  Signed requests may be stored in databases or be embedded in other
      JSON objects.  The latter includes supporting counter signatures.
      The canonicalization offered by JCS [<a href="#ref-JCS" title="&quot;JSON Canonicalization Scheme - Work in progress&quot;">JCS</a>] enables validating the
      integrity of request data at any time.

   o  For general interoperability concerns as well as due to the
      reliance on JCS, JSON request data is limited to the I-JSON
      [<a href="http://tools.ietf.org/html//rfc7493" title="&quot;The I-JSON Message Format&quot;">RFC7493</a>] subset.

   For HTTP requests that do not have a JSON body (see <a href="#section-5">Section 5</a>), the
   signature is provided in the URI [<a href="http://tools.ietf.org/html//rfc3986" title="&quot;Uniform Resource Identifier (URI): Generic Syntax&quot;">RFC3986</a>].

   Both variants utilize JWS [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] in detached mode for holding the
   signature data.

   For supporting signed HTTP responses any solution may be used.  For
   maximum "symmetry" and code reuse, the [<a href="#ref-JWSJCS" title="&quot;Combined JWS and JCS Signature Scheme - Work in progress&quot;">JWSJCS</a>] scheme should be a
   suitable candidate since it builds on the same building blocks as
   SHREQ.




<span class="grey">Rundgren                 Expires August 27, 2019                [Page 3]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in <a href="http://tools.ietf.org/html//bcp14">BCP</a>
   <a href="http://tools.ietf.org/html//bcp14">14</a> [<a href="http://tools.ietf.org/html//rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>] [<a href="http://tools.ietf.org/html//rfc8174" title="&quot;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&quot;">RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>.  Determining Request Type</span>

   In this specification the distinction between HTTP requests having a
   JSON body or not is based on the presence of a "Content-Length"
   header.  Requests without a body object are in this specification
   referred to as URI based requests.

   This also implies that not all header combinations permitted by HTTP
   can be used with this specification:

   "Content-Length"
      MUST NOT be used with URI based requests.  MUST be present for
      requests having a body and have an argument holding the length of
      the body in bytes.

   "Content-Type"
      MUST NOT be used with URI based requests.  MUST be present for
      requests having a body and have the argument "application/json".

   "Content-Encoding"
      MUST NOT be used with any requests targeting this specification.

   "Transfer-Encoding"
      MUST NOT be used with any requests targeting this specification.

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>.  Processing of JSON Based Requests</span>

   Assume you have an unsigned HTTP request like the following:

     POST /transact/pay HTTP/1.1
     Host: example.com
     Content-Type: application/json
     Content-Length: 1234

     {
       "something": "data",

            Additional application specific properties

     }



<span class="grey">Rundgren                 Expires August 27, 2019                [Page 4]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


   Adding a signature to the request above would require the following
   enhancements to the JSON payload:

     {
       "$req.uri": "https://example.com/transact/pay",
       "$req.mtd": "POST",
       "something": "data",

            Additional application specific properties

       "$req.jws": "eyJhbGciOiJIUzI1NiJ9..VHVItCBCb849imarDtjw4"
     }

   Notes:

   o  The argument to "$req.jws" (a detached JWS) was truncated for
      brevity.

   o  This specification presumes that request data is expressed as a
      JSON Object.

   o  The "$req.mtd" property is actually redundant since the HTTP
      method "POST" is the default.

   o  The ordering of properties is insignificant.

   The following subsections detail the operation for requests having an
   HTTP body.

<span class="h3"><a class="selflink" name="section-4.1" href="#section-4.1">4.1</a>.  Request Creation</span>

   Precondition: the application data to be submitted with the request
   already exists in a format serializable as a JSON Object, from now on
   referred to as "message".

   In order to create a valid signed request, the following steps (and
   ordering) MUST be adhered to:

   1.   Store the target HTTP method in a variable "targetMethod".

   2.   Store the target URI in a variable "targetURI" after having
        normalized it as described in <a href="#section-6.7">Section 6.7</a>.

   3.   Add a property "$req.uri" to "message" where the argument is a
        JSON String holding "targetURI"&gt;.

   4.   Add a property "$req.mtd" to "message" where the argument is a
        JSON String holding "targetMethod".



<span class="grey">Rundgren                 Expires August 27, 2019                [Page 5]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


        Note: for the HTTP method "POST", this step is optional because
        "POST" is the default.

   5.   If there is a need to include additional HTTP headers in the
        signed request data, perform the following steps:

        *  Create a header object as described in <a href="#section-6.3">Section 6.3</a>.

        *  Add a property "$req.hdr" to "message" where the argument is
           the JSON Object created in the preceding step.

   6.   Create a "JWS Payload" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] as described in <a href="#section-6.1">Section 6.1</a>.

   7.   Create a "JWS Protected Header" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] as described in
        <a href="#section-6.4">Section 6.4</a>.

   8.   Create a JWS string object as described in <a href="#section-6.5">Section 6.5</a>.

   9.   Add a property "$req.jws" to "message" where the argument is a
        JSON String holding the result of the preceding step.

   10.  Serialize "message" into an UTF-8 encoded byte array called
        "requestData".

   11.  Submit an HTTP [<a href="http://tools.ietf.org/html//rfc7231" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content&quot;">RFC7231</a>] compliant request to the "targetURI"
        including the following information:

        *  HTTP method set to "targetMethod".

        *  HTTP Header "Content-Length" with the argument set to the
           length of "requestData".

        *  HTTP Header "Content-Type" with the argument set to
           "application/json".

        *  All HTTP headers (if any) specified in step 5.

        *  Other HTTP headers (if any) needed by the application.

        *  An HTTP Body containing "requestData".

<span class="h3"><a class="selflink" name="section-4.2" href="#section-4.2">4.2</a>.  Request Validation</span>

   In order to validate a request the following steps MUST be performed:

   1.   Store the HTTP method of the request in a variable
        "targetMethod".




<span class="grey">Rundgren                 Expires August 27, 2019                [Page 6]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


   2.   Store the from the request recreated target URI in a variable
        "targetURI" after having normalized it as described in
        <a href="#section-6.7">Section 6.7</a>.

   3.   If the HTTP header "Content-Type" is missing or differs from
        "application/json" the service MUST reject the request with an
        HTTP 400 code (Malformed request).

   4.   If the HTTP header "Content-Length" is missing or malformed the
        service MUST reject the request with an HTTP 400 code (Malformed
        request).  Save the length data.

   5.   Read HTTP body data into a byte array with the length retrieved
        in the preceding step.

   6.   Parse the byte array created in the preceding step with a JSON
        parser and return the result in an object from now on referred
        to as "message".  If there are parsing errors the service MUST
        reject the request with an HTTP 400 code (Malformed request).

   7.   Using "message", the "$req.uri" property is read.  If "$req.uri"
        is missing or does not match "targetURI" or is not a JSON String
        the service MUST reject the request with an HTTP 400 code
        (Malformed request).

        Note: in some proxy arrangements it may be difficult retrieving
        the proper value of "targetURI".  In such cases the comparison
        with "$req.uri" MAY be disabled.

   8.   Using "message", the "$req.mtd" property is read.  if "$req.mtd"
        is missing the HTTP method is assumed to be "POST" else it is
        assumed to be the read value.  If the derived method does not
        match "targetMethod" or is not a JSON String the service MUST
        reject the request with an HTTP 400 code (Malformed request).

   9.   Using "message", the "$req.jws" property is read.  If "$req.jws"
        is missing or is not a JSON String the service MUST reject the
        request with an HTTP 400 code (Malformed request).  Decode the
        read string as described in <a href="#section-6.6">Section 6.6</a>.

   10.  If the optional "$req.hdr" property is present in "message",
        extract the argument and process it as described in <a href="#section-6.8">Section 6.8</a>.

   11.  Remove the "$req.jws" property from "message".

   12.  Create a "JWS Payload" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] object as described in
        <a href="#section-6.1">Section 6.1</a>.




<span class="grey">Rundgren                 Expires August 27, 2019                [Page 7]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


   13.  Perform signature validation as described in <a href="#section-6.9">Section 6.9</a>.

   Note: validation of application specific data can be performed
   anytime after step 6.  The action(s) to perform after a possible
   failure is out of scope for this specification.

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>.  Processing of URI Based Requests</span>

   In this specification requests without an HTTP body are referred to
   as URI based requests.  Also see <a href="#section-3">Section 3</a>.

   Assume you have an unsigned HTTP request like the following:

     GET /lookup?id=435 HTTP/1.1
     Host: example.com

   Adding a signature to this request would require the following
   enhancements to the URI:

     GET /lookup?id=435&amp;$req.jws=eyJhiJ..VHVIt HTTP/1.1
     Host: example.com

   Notes:

   o  The full URI to the sample above is as follows:

         https://example.com/lookup?id=435&amp;$req.jws=eyJhiJ..VHVIt

      This represents a complete serializable signed request object.

   o  The argument to "$req.jws" (a detached JWS) was truncated for
      brevity.

   The following subsections detail the operation for requests using an
   HTTP query string component for holding a signature.

<span class="h3"><a class="selflink" name="section-5.1" href="#section-5.1">5.1</a>.  Request Creation</span>

   In order to create a valid request, the steps (and ordering)
   described in this section MUST be adhered to:

   1.  Store the target HTTP method in a variable "targetMethod".

   2.  Store the target URI in a variable "targetURI" after having
       normalized it as described in <a href="#section-6.7">Section 6.7</a>.

   3.  Create a "JWS Payload" as described in <a href="#section-6.2">Section 6.2</a>.




<span class="grey">Rundgren                 Expires August 27, 2019                [Page 8]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


   4.  Create a "JWS Protected Header" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] as described in
       <a href="#section-6.4">Section 6.4</a>.

   5.  If HTTP headers also need to be signed the following steps are
       performed:

       *  Create an HTTP header object as described in <a href="#section-6.3">Section 6.3</a>.

       *  Add the following elements to the "JWS Protected Header"
          object:

             "crit": ["$req.hdr"]

             "$req.hdr": { ... }

          "{ ... }" denotes the HTTP header object.

   6.  Create a JWS string object as described in <a href="#section-6.5">Section 6.5</a>.

   7.  Create a query string component by concatenating "$req.jws=" with
       the JWS string created in the preceding step.  This component is
       appended to the original unsigned request URI prepended by &amp; or ?
       depending on if it is the only query component or not.

   8.  Submit an HTTP [<a href="http://tools.ietf.org/html//rfc7231" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content&quot;">RFC7231</a>] compliant request to the target URI
       including the following information:

       *  HTTP method set to "targetMethod".

       *  All HTTP headers (if any) specified in step 3.

       *  Other HTTP headers (if any) needed by the application.

<span class="h3"><a class="selflink" name="section-5.2" href="#section-5.2">5.2</a>.  Request Validation</span>

   In addition to normal validation of received data (which may be
   carried out before or after the steps outlined here), the following
   steps MUST be performed in order to validate a URI based HTTP
   request:

   1.  Store the HTTP method of the request in a variable
       "targetMethod".

   2.  Store the from the request recreated target URI in a variable
       "targetURI" after having normalized it as described in
       <a href="#section-6.7">Section 6.7</a>.





<span class="grey">Rundgren                 Expires August 27, 2019                [Page 9]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


   3.  Extract the JWS string from the "$req.jws" element which MUST
       reside in the query string of "targetURI".  If the JWS string is
       missing the service MUST reject the request with an HTTP 400 code
       (Malformed request).  Decode the argument to "$req.jws" as
       described in <a href="#section-6.6">Section 6.6</a>.

   4.  Remove the "$req.jws" query string component from "targetURI".
       Note that if the "$req.jws" query component is the last part of
       "targetURI", the delimiter immediately preceding the "$req.jws"
       component is removed, else the succeeding delimiter is removed.

   5.  if the "JWS Protected Header" object contains a "$req.hdr"
       property, perform the following steps:

       *  Verify that the "JWS Protected Header" object contains a JWS
          "crit" property holding a JSON Array with JSON String elements
          where one of the elements MUST be "$req.hdr".  If there is a
          mismatch the service MUST reject the request with an HTTP 400
          code (Malformed request).

       *  Extract the argument to "$req.hdr" from the
          "JWS Protected Header" and process it as described in
          <a href="#section-6.8">Section 6.8</a>.

   6.  Create a "JWS Payload" object as described in <a href="#section-6.2">Section 6.2</a>.

   7.  Perform signature validation as described in <a href="#section-6.9">Section 6.9</a>.

<span class="h2"><a class="selflink" name="section-6" href="#section-6">6</a>.  Common Operations</span>

   SHREQ is a modular system using shared procedures described in the
   following subsections.

<span class="h3"><a class="selflink" name="section-6.1" href="#section-6.1">6.1</a>.  Create Signable JSON Data</span>

   Unsigned request data is now supposed to reside in "message".  To
   facilitate resilience against (legitimate) variances in JSON
   processing between different platforms and systems, "message" needs
   to be canonicalized and serialized into a UTF-8 encoded byte array.
   If the used JSON tools offer intrinsic support for JCS [<a href="#ref-JCS" title="&quot;JSON Canonicalization Scheme - Work in progress&quot;">JCS</a>], this is
   typically a single operation, else the followings steps are
   performed:

   1.  Serialize "message" using standard JSON tools for the platform.

   2.  Create a canonical and UTF-8 encoded form of the data created in
       the preceding step, through an external software solution
       supporting JCS.



<span class="grey">Rundgren                 Expires August 27, 2019               [Page 10]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


   The output from JCS is intended to be used as a "JWS Payload"
   [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] object.

<span class="h3"><a class="selflink" name="section-6.2" href="#section-6.2">6.2</a>.  Create Signable URI Data</span>

   For URI based requests, the steps to create signable URI data are as
   follows:

   1.  The signable URI data consists of the "targetMethod" and the
       "targetURI", separated by a comma character.  Applied to the
       sample in <a href="#section-5">Section 5</a> that would yield the following string:

          GET,https://example.com/lookup?id=435

   2.  The resulting string is subsequently converted to UTF-8 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>]
       which applied to the sample would yield the following byte array,
       here displayed in hexadecimal notation:

          47 45 54 2c 68 74 74 70 73 3a 2f 2f 65 78 61 6d 70 6c 65 2e 63
          6f 6d 2f 6c 6f 6f 6b 75 70 3f 69 64 3d 34 33 35

   The output from the last step is assigned to a "JWS Payload"
   [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] object.

<span class="h3"><a class="selflink" name="section-6.3" href="#section-6.3">6.3</a>.  Create HTTP Header Digest</span>

   [[

      To be written...

   ]]

<span class="h3"><a class="selflink" name="section-6.4" href="#section-6.4">6.4</a>.  Create JWS Protected Header</span>

   Create a "JWS Protected Header" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] JSON object with algorithm
   and key data adapted for the application.

<span class="h3"><a class="selflink" name="section-6.5" href="#section-6.5">6.5</a>.  Create JWS String</span>

   To create a detached JWS object (see <a href="http://tools.ietf.org/html//rfc7515#appendix-F">Appendix&nbsp;F of [RFC7515]</a>),
   perform the following steps:

   1.  Serialize the previously defined "JWS Protected Header" object
       into a UTF-8 encoded byte array.

   2.  Base64Url-encode the output from the preceding step into a local
       variable "jwsProtectedHeaderB64U".




<span class="grey">Rundgren                 Expires August 27, 2019               [Page 11]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


   3.  Set local variable "signedData" to the UTF-8 encoded
       representation of the concatenation of:

          The previously defined variable "jwsProtectedHeaderB64U".

          A point character (".").

          The previously defined variable "JWS Payload", here encoded in
          Base64Url [<a href="http://tools.ietf.org/html//rfc4648" title="&quot;The Base16, Base32, and Base64 Data Encodings&quot;">RFC4648</a>].

   4.  Use the designated signature key, signature algorithm and
       "signedData" to create a "JWS Signature" object (byte array).

   5.  Return the string consisting of the concatenation of:

          The previously defined variable "jwsProtectedHeaderB64U".

          Two point characters ("..").

          The previously defined variable "JWS Signature", here encoded
          in Base64Url [<a href="http://tools.ietf.org/html//rfc4648" title="&quot;The Base16, Base32, and Base64 Data Encodings&quot;">RFC4648</a>].

<span class="h3"><a class="selflink" name="section-6.6" href="#section-6.6">6.6</a>.  Decode JWS String</span>

   The following processing steps presume that there is an input string
   holding a detached JWS compact object, here called "jwsString":

   1.  Verify that "jwsString" has the syntax "header..signature".

   2.  Assign the "header" portion of "jwsString" to a variable
       "jwsProtectedHeaderB64U".

   3.  Base64Url-decode "jwsProtectedHeaderB64U" into a byte array.

   4.  Parse the output from the preceding step with a JSON parser and
       assume that the result is a "JWS Protected Header" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>]
       object.

   5.  Base64Url-decode the "signature" portion of "jwsString" into a
       byte array.

   6.  Use the output from the preceding step to create a
       "JWS Signature" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] object.

   If any of the steps fails, the service MUST reject the request with
   an HTTP 400 code (Malformed request).





<span class="grey">Rundgren                 Expires August 27, 2019               [Page 12]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


<span class="h3"><a class="selflink" name="section-6.7" href="#section-6.7">6.7</a>.  Normalize Target URI</span>

   [[

      To be written...

   ]]

<span class="h3"><a class="selflink" name="section-6.8" href="#section-6.8">6.8</a>.  Validate HTTP Header Digest</span>

   [[

      To be written...

   ]]

<span class="h3"><a class="selflink" name="section-6.9" href="#section-6.9">6.9</a>.  Validate Signature</span>

   Validation of the detached JWS object (see <a href="http://tools.ietf.org/html//rfc7515#appendix-F">Appendix&nbsp;F of [RFC7515]</a>),
   using the previously extracted and decoded objects requires the
   following steps:

   1.  Verify that the received "JWS Protected Header" contains a JWS
       algorithm ("alg") and key identifiers that matches the needs of
       the application.

   2.  Retrieve the signature validation key.  This part is application
       specific since the key may be implicit, specified by a key ID
       ("kid") or be supplied in a certificate path ("x5c").

   3.  Set a local variable "signedData" to the UTF-8 encoded
       representation of the concatenation of:

          The previously defined variable "jwsProtectedHeaderB64U".

          A point character (".").

          The previously defined variable "JWS Payload", here encoded in
          Base64Url [<a href="http://tools.ietf.org/html//rfc4648" title="&quot;The Base16, Base32, and Base64 Data Encodings&quot;">RFC4648</a>].

   4.  Validate the signature using the algorithm retrieved in step 1,
       the signature validation key from step 2, "signedData" from step
       3 and the previously collected "JWS Signature" object (byte
       array).

   If any of these steps fail, the service MUST reject the request with
   an HTTP 401 code (Unauthorized).




<span class="grey">Rundgren                 Expires August 27, 2019               [Page 13]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


<span class="h2"><a class="selflink" name="section-7" href="#section-7">7</a>.  Local Naming Conventions</span>

   Although the "$req.*" property names are highly RECOMMENDED, this
   specfication permits (=being considered as compatible), the use of
   local naming conventions as long as the specified procedures and
   formats are adhered to.

   Local naming conventions MUST be properly communicated in the
   community using them.

<span class="h2"><a class="selflink" name="section-8" href="#section-8">8</a>.  MIME Multipart Requests</span>

   [[

      It should be possible to extending the JSON based request to also
      support attachments.  This is currently out of scope for this
      specification.

   ]]

<span class="h2"><a class="selflink" name="section-9" href="#section-9">9</a>.  IANA Considerations</span>

   This document currently has no IANA actions but the reserved property
   names below could be candidates for IANA registration:

   $req.uri
      Property holding a normalized target URI.

   $req.mtd
      Property holding an HTTP method name.

   $req.hdr
      Property holding a JSON object containing a list of HTTP headers
      and a consolidated hash of the headers and their the arguments.

   $req.jws
      Property holding a detached JWS signature.

<span class="h2"><a class="selflink" name="section-10" href="#section-10">10</a>.  Security Considerations</span>

   Systems implementing this application note are subject to the same
   security considerations as JCS and JWS.

<span class="h2"><a class="selflink" name="section-11" href="#section-11">11</a>.  Acknowledgements</span>

   TBD.





<span class="grey">Rundgren                 Expires August 27, 2019               [Page 14]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-15" id="page-15" href="#page-15" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


<span class="h2"><a class="selflink" name="section-12" href="#section-12">12</a>.  References</span>

<span class="h3"><a class="selflink" name="section-12.1" href="#section-12.1">12.1</a>.  Normative References</span>

   [<a name="ref-JCS" id="ref-JCS">JCS</a>]      A. Rundgren, B. Jordan, S. Erdtman, "JSON Canonicalization
              Scheme - Work in progress", &lt;<a href="https://tools.ietf.org/html/draft-rundgren-json-canonicalization-scheme-05">https://tools.ietf.org/html/</a>
              <a href="https://tools.ietf.org/html/draft-rundgren-json-canonicalization-scheme-05">draft-rundgren-json-canonicalization-scheme-05</a>&gt;.

   [<a name="ref-JWSJCS" id="ref-JWSJCS">JWSJCS</a>]   A. Rundgren, "Combined JWS and JCS Signature Scheme - Work
              in progress", &lt;<a href="https://github.com/cyberphone/jws-jcs">https://github.com/cyberphone/jws-jcs</a>&gt;.

   [<a name="ref-RFC2119" id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="http://tools.ietf.org/html//bcp14">BCP 14</a>, <a href="http://tools.ietf.org/html//rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a name="ref-RFC3986" id="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              <a href="http://tools.ietf.org/html//rfc3986">RFC 3986</a>, DOI 10.17487/RFC3986, January 2005,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;.

   [<a name="ref-RFC4648" id="ref-RFC4648">RFC4648</a>]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", <a href="http://tools.ietf.org/html//rfc4648">RFC 4648</a>, DOI 10.17487/RFC4648, October 2006,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;.

   [<a name="ref-RFC7231" id="ref-RFC7231">RFC7231</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", <a href="http://tools.ietf.org/html//rfc7231">RFC 7231</a>,
              DOI 10.17487/RFC7231, June 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.

   [<a name="ref-RFC7493" id="ref-RFC7493">RFC7493</a>]  Bray, T., Ed., "The I-JSON Message Format", <a href="http://tools.ietf.org/html//rfc7493">RFC 7493</a>,
              DOI 10.17487/RFC7493, March 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7493">https://www.rfc-editor.org/info/rfc7493</a>&gt;.

   [<a name="ref-RFC7515" id="ref-RFC7515">RFC7515</a>]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", <a href="http://tools.ietf.org/html//rfc7515">RFC 7515</a>, DOI 10.17487/RFC7515, May
              2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7515">https://www.rfc-editor.org/info/rfc7515</a>&gt;.

   [<a name="ref-RFC8174" id="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in <a href="http://tools.ietf.org/html//rfc2119">RFC</a>
              <a href="http://tools.ietf.org/html//rfc2119">2119</a> Key Words", <a href="http://tools.ietf.org/html//bcp14">BCP 14</a>, <a href="http://tools.ietf.org/html//rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a name="ref-RFC8259" id="ref-RFC8259">RFC8259</a>]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, <a href="http://tools.ietf.org/html//rfc8259">RFC 8259</a>,
              DOI 10.17487/RFC8259, December 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8259">https://www.rfc-editor.org/info/rfc8259</a>&gt;.





<span class="grey">Rundgren                 Expires August 27, 2019               [Page 15]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-16" id="page-16" href="#page-16" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


   [<a name="ref-UNICODE" id="ref-UNICODE">UNICODE</a>]  The Unicode Consortium, "The Unicode Standard, Version
              10.0.0",
              &lt;<a href="https://www.unicode.org/versions/Unicode10.0.0/">https://www.unicode.org/versions/Unicode10.0.0/</a>&gt;.

<span class="h3"><a class="selflink" name="section-12.2" href="#section-12.2">12.2</a>.  Informal References</span>

   [<a name="ref-AWS" id="ref-AWS">AWS</a>]      Amazon.com, "Signing AWS API Requests",
              &lt;<a href="https://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html">https://docs.aws.amazon.com/general/latest/gr/</a>
              <a href="https://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html">signing_aws_api_requests.html</a>&gt;.

   [<a name="ref-FAPI" id="ref-FAPI">FAPI</a>]     Open ID, "Financial-grade API",
              &lt;<a href="https://openid.net/wg/fapi/">https://openid.net/wg/fapi/</a>&gt;.

   [<a name="ref-HTTPSIG" id="ref-HTTPSIG">HTTPSIG</a>]  M. Cavage, M. Sporny, "Signing HTTP Messages",
              &lt;<a href="https://tools.ietf.org/html/draft-cavage-http-signatures-10">https://tools.ietf.org/html/</a>
              <a href="https://tools.ietf.org/html/draft-cavage-http-signatures-10">draft-cavage-http-signatures-10</a>&gt;.

   [<a name="ref-OBIE" id="ref-OBIE">OBIE</a>]     Open Banking UK, "Open Banking API",
              &lt;<a href="https://www.openbanking.org.uk/">https://www.openbanking.org.uk/</a>&gt;.

   [<a name="ref-REST" id="ref-REST">REST</a>]     Roy Fielding, "Architectural Styles and the Design of
              Network-based Software Architectures",
              &lt;<a href="http://roy.gbiv.com/pubs/dissertation/top.htm">http://roy.gbiv.com/pubs/dissertation/top.htm</a>&gt;.

   [<a name="ref-STET" id="ref-STET">STET</a>]     STET, "PSD2 API V1.4.1", &lt;<a href="https://www.stet.eu/en/psd2/">https://www.stet.eu/en/psd2/</a>&gt;.

<span class="h3"><a class="selflink" name="section-12.3" href="#section-12.3">12.3</a>.  URIs</span>

   [<a name="ref-1" id="ref-1">1</a>] <a href="https://cyberphone.github.io/ietf-signed-http-requests">https://cyberphone.github.io/ietf-signed-http-requests</a>

<span class="h2"><a class="selflink" name="appendix-A" href="#appendix-A">Appendix A</a>.  Other Signed HTTP Request Solutions</span>

   This appendix briefly outlines a few other solutions addressing
   Signed HTTP Requests.

<span class="h3"><a class="selflink" name="appendix-A.1" href="#appendix-A.1">A.1</a>.  Amazon Web Services</span>

   Amazon Web Sevices provides a system for their clients using HTTP
   headers holding security constructs while the digested HTTP body may
   hold any valid media type.  For more information see the [<a href="#ref-AWS" title="&quot;Signing AWS API Requests&quot;">AWS</a>].
   Signatures may also be added to query strings in a similar fashion to
   <a href="#section-5">Section 5</a>.

<span class="h3"><a class="selflink" name="appendix-A.2" href="#appendix-A.2">A.2</a>.  HTTP Signatures</span>

   HTTP Signatures is a system using HTTP headers holding security
   constructs while the (optional) digested HTTP body may hold any valid
   media type.  This scheme has been adopted by the French Open Banking



<span class="grey">Rundgren                 Expires August 27, 2019               [Page 16]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-17" id="page-17" href="#page-17" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


   API [<a href="#ref-STET" title="&quot;PSD2 API V1.4.1&quot;">STET</a>].  For more information see the Internet draft [<a href="#ref-HTTPSIG" title="&quot;Signing HTTP Messages&quot;">HTTPSIG</a>].
   HTTP Signatures also supports signed response data.

<span class="h3"><a class="selflink" name="appendix-A.3" href="#appendix-A.3">A.3</a>.  Open Banking (UK)</span>

   The current (3.1) version of the Open Banking API [<a href="#ref-OBIE" title="&quot;Open Banking API&quot;">OBIE</a>] use a scheme
   where a dedicated HTTP header holds a detached JWS signature covering
   a clear text JSON message in the HTTP body:

     POST /transact/pay HTTP/1.1
     Host: example.com
     Content-Type: application/json
     x-jws-signature: eyJhbGciOiJSUzI1N..SD7xMbpL-2QgwUsAlMGzw
     Content-Length: 2765

     {
        "something": "data",

            Additional application specific properties

     }

   Notes:

   o  The HTTP URI, method and headers are unsigned.

   o  The signature argument (a JWS) was truncated for brevity.

<span class="h3"><a class="selflink" name="appendix-A.4" href="#appendix-A.4">A.4</a>.  Financial API</span>

   The current version (Draft 06) of the financial API [<a href="#ref-FAPI" title="&quot;Financial-grade API&quot;">FAPI</a>] use a
   scheme where the payload is signed using JWS in Base64Url [<a href="http://tools.ietf.org/html//rfc4648" title="&quot;The Base16, Base32, and Base64 Data Encodings&quot;">RFC4648</a>]
   mode:

     POST /transact/pay HTTP/1.1
     Host: example.com
     Content-Type: application/jws
     Content-Length: 1288

     eyJhbGcRjIn0.ew0KICJfds56gty5ypc3MiOiA.2QgwUsA565656lMGzw

   Notes:

   o  The HTTP URI, method and headers are unsigned.

   o  The JWS signature was truncated for brevity.





<span class="grey">Rundgren                 Expires August 27, 2019               [Page 17]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-18" id="page-18" href="#page-18" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>     February 2019</span>


<span class="h2"><a class="selflink" name="appendix-B" href="#appendix-B">Appendix B</a>.  Development Portal</span>

   The SHREQ specification is currently developed at:
   <a href="https://cyberphone.github.io/ietf-signed-http-requests">https://cyberphone.github.io/ietf-signed-http-requests</a> [<a href="#ref-1">1</a>].




Author's Address

   Anders Rundgren
   Independent
   Montpellier
   France

   Email: anders.rundgren.net@gmail.com
   URI:   <a href="https://www.linkedin.com/in/andersrundgren/">https://www.linkedin.com/in/andersrundgren/</a>


































Rundgren                 Expires August 27, 2019               [Page 18]

</pre><br />
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129b, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
</body>
</html>
