<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.129c" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />

    <link rel="icon" href="" type="image/png" />
    <link rel="shortcut icon" href="" type="image/png" />
    <title>draft-rundgren-signed-http-requests-2.txt - Signed HTTP Requests (SHREQ)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo "
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>

<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Network Working Group                                        A. Rundgren
Internet-Draft                                               Independent
Intended status: Standards Track                             May 5, 2019
Expires: November 6, 2019


                      <span class="h1">Signed HTTP Requests (SHREQ)</span>
                 <span class="h1">draft-rundgren-signed-http-requests-01</span>

Abstract

   The SHREQ specification describes how the JSON Web Signature (JWS)
   specification combined with the JSON Canonicalization Scheme (JCS),
   can be utilized to support HTTP based applications needing digitally
   signed requests.  SHREQ is specifically tailored for Web applications
   using JSON as data interchange format.  There is also a SHREQ scheme
   for HTTP requests that do not have a body ("payload") like GET.
   SHREQ was designed to be agnostic with respect to REST concepts
   versus traditional GET/POST schemes.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of <a href="http://tools.ietf.org/html//bcp78">BCP 78</a> and <a href="http://tools.ietf.org/html//bcp79">BCP 79</a>.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at <a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a>.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on November 6, 2019.

Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="http://tools.ietf.org/html//bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must



<span class="grey">Rundgren                Expires November 6, 2019                [Page 1]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  HTTP Processing . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-3.1">3.1</a>.  Determining Request Type  . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-3.2">3.2</a>.  Return Codes  . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-4">4</a>.  Processing of JSON Based Requests . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-4.1">4.1</a>.  Request Creation  . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-4.2">4.2</a>.  Request Validation  . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-5">5</a>.  Processing of URI Based Requests  . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-5.1">5.1</a>.  Request Creation  . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-5.2">5.2</a>.  Request Validation  . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-6">6</a>.  Common Operations . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-6.1">6.1</a>.  Create Signable JSON Data . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-6.2">6.2</a>.  Create Signable URI Data  . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-6.3">6.3</a>.  Create HTTP Header Object . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-6.4">6.4</a>.  Create JWS Protected Header . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-6.5">6.5</a>.  Create JWS String . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-6.6">6.6</a>.  Decode JWS String . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-6.7">6.7</a>.  Normalize Target URI  . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-6.8">6.8</a>.  Normalize Header Data . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-6.9">6.9</a>.  Validate HTTP Header Object . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-6.10">6.10</a>. Validate JWS Signature  . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#section-6.11">6.11</a>. Time Stamps . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
     <a href="#section-6.12">6.12</a>. Hash Algorithms . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   <a href="#section-7">7</a>.  Local Naming Conventions  . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   <a href="#section-8">8</a>.  MIME Multipart Requests . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   <a href="#section-9">9</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   <a href="#section-10">10</a>. Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
   <a href="#section-11">11</a>. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
   <a href="#section-12">12</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
     <a href="#section-12.1">12.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
     <a href="#section-12.2">12.2</a>.  Informal References  . . . . . . . . . . . . . . . . . .  <a href="#page-24">24</a>
   <a href="#appendix-A">Appendix A</a>.  Test Vectors . . . . . . . . . . . . . . . . . . . .  <a href="#page-24">24</a>
     <a href="#appendix-A.1">A.1</a>.  Type=URI, Method=GET, Algorithm=HS256 . . . . . . . . . .  <a href="#page-24">24</a>
     <a href="#appendix-A.2">A.2</a>.  Type=JSON, Method=POST, Algorithm=ES256 . . . . . . . . .  <a href="#page-25">25</a>
     <a href="#appendix-A.3">A.3</a>.  Type=JSON, Method=PUT, Algorithm=ES256  . . . . . . . . .  <a href="#page-25">25</a>
     <a href="#appendix-A.4">A.4</a>.  Type=URI, Method=DELETE, Algorithm=RS256  . . . . . . . .  <a href="#page-26">26</a>
   <a href="#appendix-B">Appendix B</a>.  Other Signed HTTP Request Solutions  . . . . . . . .  <a href="#page-27">27</a>
     <a href="#appendix-B.1">B.1</a>.  Amazon Web Services . . . . . . . . . . . . . . . . . . .  <a href="#page-27">27</a>
     <a href="#appendix-B.2">B.2</a>.  HTTP Signatures . . . . . . . . . . . . . . . . . . . . .  <a href="#page-27">27</a>
     <a href="#appendix-B.3">B.3</a>.  Open Banking (UK) . . . . . . . . . . . . . . . . . . . .  <a href="#page-28">28</a>
     <a href="#appendix-B.4">B.4</a>.  Financial API . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-28">28</a>



<span class="grey">Rundgren                Expires November 6, 2019                [Page 2]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   <a href="#appendix-C">Appendix C</a>.  Development Portal . . . . . . . . . . . . . . . . .  <a href="#page-28">28</a>
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-29">29</a>

<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>.  Introduction</span>

   Currently there is no standard for digitally signing HTTP [<a href="http://tools.ietf.org/html//rfc7230" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>]
   [<a href="http://tools.ietf.org/html//rfc7231" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content&quot;">RFC7231</a>] requests.  This has led to the development of a multitude
   of more or less proprietary solutions (see <a href="#appendix-B">Appendix B</a>), typically
   building on using HTTP header data for holding security constructs,
   while JSON request data is provided in clear in the HTTP body.

   SHREQ is intended to provide a standardized alternative, including
   supporting the REST [<a href="#ref-REST" title="&quot;Architectural Styles and the Design of Network-based Software Architectures&quot;">REST</a>] concept.

   SHREQ builds on a common security model where all elements of an HTTP
   request are signed:

   o  HTTP URI.

   o  HTTP method.

   o  HTTP body (if applicable).

   o  Optional: Additional HTTP headers as defined by applications
      implementing this specification.

   In addition there is a mandatory time stamp.

   One of the design goals was turning signed requests into self-
   contained objects.  To achieve this for HTTP requests having a JSON
   [<a href="http://tools.ietf.org/html//rfc8259" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC8259</a>] body (see <a href="#section-4">Section 4</a>), the request data also carries the
   signature.  This arrangement has certain implications:

   o  Signed requests may be stored in databases or be embedded in other
      JSON objects.  The latter includes supporting counter signatures.
      The canonicalization offered by JCS [<a href="#ref-JCS" title="&quot;JSON Canonicalization Scheme - Work in progress&quot;">JCS</a>] enables validating the
      integrity of request data at any time.

   o  For general interoperability concerns as well as due to the
      reliance on JCS, JSON request data is limited to the I-JSON
      [<a href="http://tools.ietf.org/html//rfc7493" title="&quot;The I-JSON Message Format&quot;">RFC7493</a>] subset.

   For HTTP requests that do not have a JSON body (see <a href="#section-5">Section 5</a>), the
   signature and additional request data is added to the original URI
   [<a href="http://tools.ietf.org/html//rfc3986" title="&quot;Uniform Resource Identifier (URI): Generic Syntax&quot;">RFC3986</a>], making signed URI-only requests self-contained and
   serializable as well.  For simplicity such requests are (in this
   specification NB), referred to as URI based requests.




<span class="grey">Rundgren                Expires November 6, 2019                [Page 3]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   Both variants utilize JWS [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] for holding the signature data.

   For supporting signed HTTP responses any solution may be used.  For
   maximum "symmetry" and code reuse, the [<a href="#ref-JWSJCS" title="&quot;Combined JWS and JCS Signature Scheme - Work in progress&quot;">JWSJCS</a>] scheme should be a
   suitable candidate since it builds on the same building blocks as
   SHREQ.

   The intended audiences of this document are Web tool vendors, as well
   as designers of secure Web applications.

<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in <a href="http://tools.ietf.org/html//bcp14">BCP</a>
   <a href="http://tools.ietf.org/html//bcp14">14</a> [<a href="http://tools.ietf.org/html//rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>] [<a href="http://tools.ietf.org/html//rfc8174" title="&quot;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&quot;">RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>.  HTTP Processing</span>

   The following subsections describe HTTP specifics associated with
   this specification.

<span class="h3"><a class="selflink" name="section-3.1" href="#section-3.1">3.1</a>.  Determining Request Type</span>

   In this specification the distinction between HTTP requests having a
   JSON body or not is based on the presence of a "Content-Length"
   header.  Requests without a body object are in this specification
   referred to as URI based requests.

   This also implies that not all header combinations permitted by HTTP
   can be used with this specification:

   "Content-Length"
      MUST NOT be used with URI based requests.  MUST be present for
      requests having a body and have an argument holding the length of
      the body in bytes.

   "Content-Type"
      MUST NOT be used with URI based requests.  MUST be present for
      requests having a body and have the argument "application/json".

   "Content-Encoding"
      MUST NOT be used with any requests targeting this specification.

   "Transfer-Encoding"
      MUST NOT be used with any requests targeting this specification.




<span class="grey">Rundgren                Expires November 6, 2019                [Page 4]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


<span class="h3"><a class="selflink" name="section-3.2" href="#section-3.2">3.2</a>.  Return Codes</span>

   This specification utilizes a single HTTP return code 400 (Bad
   request) for indicating syntax or security errors.  Since the number
   of possible error conditions is significant, it is RECOMMENDED to
   accompany the error code with a short explanation in "text/plain"
   format in the HTTP Body like:

     - Missing ".secinf" element
     - Invalid "alg": es256
     - Unknown "kid": example.com:rsa:2018.1
     - com.example.jose.Core.validate(2653): Signature validation error
     - Missing header variable "x-testing"

   Communities using this specification MAY customize error codes if
   needed.  However, in practice, it usually turns out to be of little
   value compared to a text message and a generic "hard error" code
   since neither users nor machines can do very much on their own to fix
   errors that are outside of normal processing.

   Application level errors are dealt with in an application specific
   manner.  As an example a bank application which finds out that the
   customer do not have enough funds to perform a transaction would
   presumably not return an HTTP error code but rather a specifically
   crafted error message to be displayed to the user.

   Return codes for successful operation are application specific but
   are typically 200 (OK) or 201 (Created).

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>.  Processing of JSON Based Requests</span>

   Assume there is an unsigned HTTP request like the following:

     POST /foo HTTP/1.1
     Host: example.com
     Content-Type: application/json
     Content-Length: 1234

     {
       "something": "data",

            Additional application specific properties

     }

   Adding a signature to the request above would require the following
   enhancements to the JSON payload:




<span class="grey">Rundgren                Expires November 6, 2019                [Page 5]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


     {
       "something": "data",

            Additional application specific properties

       ".secinf": {
         "uri": "https://example.com/foo",
         "mtd": "POST",
         "iat": 1551709923,
         "jws": "eyJhbGciOiJIUzI1NiJ9..VHVItCBCb849imarDtjw4"
       }
     }

   Notes:

   o  This specification presumes that request data featured in an HTTP
      body is expressed as a JSON Object.

   o  The "uri" property holds a normalized target URI.

   o  The "mtd" property holds the expected HTTP method.  In the example
      it is actually redundant since the absence of a "mtd" property
      defaults to "POST" for JSON based requests in this specification.

   o  The "iat" property holds a time stamp in UNIX "epoch" format.

   o  The argument to "jws" (a detached compact JWS) was truncated for
      brevity.

   The following subsections detail the operation for requests having an
   HTTP body.

<span class="h3"><a class="selflink" name="section-4.1" href="#section-4.1">4.1</a>.  Request Creation</span>

   Precondition: the application data to be submitted with the request
   already exists in a format serializable as a JSON Object, from now on
   referred to as "message".

   In order to create a valid signed JSON request, the following steps
   (and ordering) MUST be adhered to:

   1.   Store the target HTTP method in a variable "targetMethod".

   2.   Store the target URI in a variable "targetURI" after having
        normalized it as described in <a href="#section-6.7">Section 6.7</a>.

   3.   Add a JSON Object called ".secinf" to "message".




<span class="grey">Rundgren                Expires November 6, 2019                [Page 6]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   4.   Add a property "uri" to ".secinf" where the argument is a JSON
        String holding a copy of "targetURI".

   5.   Add a property "mtd" to ".secinf" where the argument is a JSON
        String holding a copy of "targetMethod".

        Note: for the HTTP method "POST", this step is optional because
        "POST" is the default for JSON based requests.

   6.   If there is a need to include additional HTTP headers in the
        signed request data, perform the following steps:

        *  Derive (or define) the hash algorithm to use as described in
           <a href="#section-6.12">Section 6.12</a>.  Save the algorithm in a variable
           "hashAlgorithm".

        *  Create a header object as described in <a href="#section-6.3">Section 6.3</a>.

   7.   Add a time stamp property (see <a href="#section-6.11">Section 6.11</a>) to ".secinf".

        Note: if the application data already contains a suitable time
        stamp property, this step MAY be excluded.

   8.   Create a "JWS Payload" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] as described in <a href="#section-6.1">Section 6.1</a>.

   9.   Create a "JWS Protected Header" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] as described in
        <a href="#section-6.4">Section 6.4</a>.

   10.  Create a JWS string object as described in <a href="#section-6.5">Section 6.5</a>.

   11.  Add a property "jws" to ".secinf" where the argument is a JSON
        String holding the result of the preceding step.

   12.  Serialize "message" into an UTF-8 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>] encoded byte array
        called "requestData".

   13.  Submit an HTTP compliant request to the "targetURI" including
        the following information:

        *  HTTP method set to "targetMethod".

        *  HTTP Header "Content-Length" with the argument set to the
           length of "requestData".

        *  HTTP Header "Content-Type" with the argument set to
           "application/json".

        *  All HTTP headers (if any) specified in step 6.



<span class="grey">Rundgren                Expires November 6, 2019                [Page 7]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


        *  Other HTTP headers (if any) needed by the application.

        *  An HTTP Body containing a copy of "requestData".

<span class="h3"><a class="selflink" name="section-4.2" href="#section-4.2">4.2</a>.  Request Validation</span>

   In order to validate a request the following steps MUST be performed:

   1.   Store the HTTP method of the request in a variable
        "targetMethod".

   2.   Store the from the request recreated target URI in a variable
        "targetURI" after having normalized it as described in
        <a href="#section-6.7">Section 6.7</a>.

   3.   If the HTTP header "Content-Type" is missing or differs from
        "application/json" the service MUST reject the request (see
        <a href="#section-3.2">Section 3.2</a>).

   4.   If the HTTP header "Content-Length" is missing or malformed the
        service MUST reject the request (see <a href="#section-3.2">Section 3.2</a>).  Save the
        length data.

   5.   Read HTTP body data into a byte array with the length retrieved
        in the preceding step.

   6.   Parse the byte array created in the preceding step with a JSON
        parser and return the result in an object from now on referred
        to as "message".  If there are parsing errors or if "message" is
        not a JSON Object the service MUST reject the request (see
        <a href="#section-3.2">Section 3.2</a>).

   7.   Using "message", retrieve a JSON Object called ".secinf".  If
        ".secinf" is missing or is not a JSON Object the service MUST
        reject the request (see <a href="#section-3.2">Section 3.2</a>).

   8.   Using ".secinf", the property "jws" is read.  If "jws" is
        missing or is not a JSON String the service MUST reject the
        request (see <a href="#section-3.2">Section 3.2</a>).  Decode the read string as described
        in <a href="#section-6.6">Section 6.6</a>.

   9.   Using ".secinf", the property "uri" is read.  If "uri" is
        missing or does not match "targetURI" or is not a JSON String
        the service MUST reject the request (see <a href="#section-3.2">Section 3.2</a>).

        Note: in some proxy arrangements it may be difficult retrieving
        the proper value of "targetURI".  In such cases the comparison
        with "uri" MAY be disabled.



<span class="grey">Rundgren                Expires November 6, 2019                [Page 8]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   10.  Using ".secinf", the property "mtd" is read.  if "mtd" is
        missing the HTTP method is assumed to be "POST" else it is
        assumed to be the read value.  If the derived method does not
        match "targetMethod" or is not a JSON String the service MUST
        reject the request (see <a href="#section-3.2">Section 3.2</a>).

   11.  If the optional "hdr" property is present in ".secinf" perform
        the following steps:

        *  Derive the hash algorithm to use as described in
           <a href="#section-6.12">Section 6.12</a>.  Save the algorithm in a variable
           "hashAlgorithm".

        *  Process the argument of "hdr" as described in <a href="#section-6.9">Section 6.9</a>.

   12.  Using ".secinf", the property "iat" (see <a href="#section-6.11">Section 6.11</a>) is read.
        if "iat" is missing or is not a JSON Number the service MUST
        reject the request (see <a href="#section-3.2">Section 3.2</a>).

        Note: if the application data already contains a suitable time
        stamp property, this step MAY be excluded.

   13.  Remove the "jws" property from ".secinf".

   14.  Create a "JWS Payload" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] as described in <a href="#section-6.1">Section 6.1</a>.

   15.  Perform signature validation as described in <a href="#section-6.10">Section 6.10</a>.

   Note: validation of application specific data can be performed
   anytime after step 6.  The action(s) to perform after a possible
   failure is out of scope for this specification (see <a href="#section-3.2">Section 3.2</a>).

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>.  Processing of URI Based Requests</span>

   Assume there is an unsigned HTTP request like the following:

     GET /users?id=435 HTTP/1.1
     Host: example.com

   The full URI would be as follows:

     https://example.com/users?id=435

   Adding a signature to this request according to this specification
   would return the following URI:

     https://example.com/users?id=435&amp;.jws=eyJhhiJ.eyJ7fgw.VHVIt




<span class="grey">Rundgren                Expires November 6, 2019                [Page 9]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   Notes:

   o  The revised URI represents a complete serializable signed request
      object.

   o  The argument to ".jws" (a standard compact JWS) was truncated for
      brevity.

   The middle component of the JWS string ("JWS Payload"), contains
   Base64Url encoded signed data related to the request.  It should
   (after Base64Url decoding) yield a JSON Object like the following:

     {
       "htu": "WUjqfXPztLzzXRCs6EcWCw-GC9hSL7hwCR1nG2FSvQ8",
       "mtd": "GET",
       "iat": 1551863696
     }

   Notes:

   o  The property "htu" holds a Base64Url encoded value of the
      normalized target URI after it has been hashed by the hash
      algorithm associated with the JWS signature.

   o  The "mtd" property holds the expected HTTP method.  In the example
      it is actually redundant since the absence of a "mtd" property
      defaults to "GET" for URI based requests in this specification.

   o  The "iat" property holds a time stamp in UNIX "epoch" format.

   The following subsections detail the operation for requests using an
   HTTP query string component for holding a signature.

<span class="h3"><a class="selflink" name="section-5.1" href="#section-5.1">5.1</a>.  Request Creation</span>

   In order to create a valid signed URI request, the following steps
   (and ordering) MUST be adhered to:

   1.   Store the target HTTP method in a variable "targetMethod".

   2.   Store the target URI in a variable "targetURI" after having
        normalized it as described in <a href="#section-6.7">Section 6.7</a>.

   3.   Create an empty JSON Object from now on referred to as
        ".secinf".

   4.   Derive (or define) the hash algorithm to use as described in
        <a href="#section-6.12">Section 6.12</a>.  Save the algorithm in a variable "hashAlgorithm".



<span class="grey">Rundgren                Expires November 6, 2019               [Page 10]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   5.   Add a property "htu" (Hashed Target URI) to ".secinf" where the
        argument is a JSON String holding the outcome of the process
        described in <a href="#section-6.2">Section 6.2</a>.

   6.   Add a property "mtd" to ".secinf" where the argument is a JSON
        String holding a copy of "targetMethod".

        Note: for the HTTP method "GET", this step is optional because
        "GET" is the default for URI based requests.

   7.   If there is a need to include additional HTTP headers in the
        signed request data, create a header object as described in
        <a href="#section-6.3">Section 6.3</a>.

   8.   Add a time stamp property (see <a href="#section-6.11">Section 6.11</a>) to ".secinf".

   9.   Serialize the ".secinf" JSON Object into a UTF-8 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>] byte
        array representing a "JWS Payload" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>].

   10.  Create a "JWS Protected Header" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] as described in
        <a href="#section-6.4">Section 6.4</a>.

   11.  Create a JWS string object as described in <a href="#section-6.5">Section 6.5</a>.

   12.  Create a query string component by concatenating ".jws=" with
        the JWS string created in the preceding step.  This component is
        appended to the original unsigned request URI prepended by &amp; or
        ? depending on if it is the only query component or not.

   13.  Submit an HTTP compliant request to the target URI including the
        following information:

        *  HTTP method set to "targetMethod".

        *  All HTTP headers (if any) specified in step 7.

        *  Other HTTP headers (if any) needed by the application.

<span class="h3"><a class="selflink" name="section-5.2" href="#section-5.2">5.2</a>.  Request Validation</span>

   In addition to normal validation of received data (which may be
   carried out before or after the steps outlined here), the following
   steps MUST be performed in order to validate a URI based HTTP
   request:

   1.   Store the HTTP method of the request in a variable
        "targetMethod".




<span class="grey">Rundgren                Expires November 6, 2019               [Page 11]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   2.   Store the from the request recreated target URI in a variable
        "targetURI" after having normalized it as described in
        <a href="#section-6.7">Section 6.7</a>.

   3.   Extract the JWS string from the ".jws" element which MUST reside
        in the query string of "targetURI".  If the JWS string is
        missing the service MUST reject the request (see <a href="#section-3.2">Section 3.2</a>).

   4.   Decode the argument of the preceding step as described in
        <a href="#section-6.6">Section 6.6</a>.

   5.   Remove the ".jws" query string component from "targetURI".  Note
        that if the ".jws" query component is the last part of
        "targetURI", the delimiter immediately preceding the ".jws"
        component is removed, else the succeeding delimiter is removed.

   6.   Parse "JWS Payload" (created in step 4) with a JSON parser and
        from now on refer to the result as ".secinf".  If ".secinf" is
        not a JSON Object the service MUST reject the request (see
        <a href="#section-3.2">Section 3.2</a>).

   7.   Derive the hash algorithm to use as described in <a href="#section-6.12">Section 6.12</a>.
        Save the algorithm in a variable "hashAlgorithm".

   8.   Using ".secinf" the property "htu" is read.  If "htu" is missing
        or is not a JSON String the service MUST reject the request (see
        <a href="#section-3.2">Section 3.2</a>).

   9.   Perform the operation described in <a href="#section-6.2">Section 6.2</a> and compare the
        outcome with the argument to "htu".  If these value do not match
        the service MUST reject the request (see <a href="#section-3.2">Section 3.2</a>).

        Note: in some proxy arrangements it may be difficult retrieving
        the proper value of "targetURI".  In such cases the comparison
        with "htu" MAY be disabled.

   10.  Using ".secinf", the property "mtd" is read.  if "mtd" is
        missing the HTTP method is assumed to be "GET" else it is
        assumed to be the read value.  If the derived method does not
        match "targetMethod" or is not a JSON String the service MUST
        reject the request (see <a href="#section-3.2">Section 3.2</a>).

   11.  If the optional "hdr" property is present in ".secinf", process
        the argument of "hdr" as described in <a href="#section-6.9">Section 6.9</a>.

   12.  Using ".secinf", the property "iat" (see <a href="#section-6.11">Section 6.11</a>) is read.
        if "iat" is missing or is not a JSON Number the service MUST
        reject the request (see <a href="#section-3.2">Section 3.2</a>).



<span class="grey">Rundgren                Expires November 6, 2019               [Page 12]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   13.  Perform signature validation as described in <a href="#section-6.10">Section 6.10</a>.

   Note: validation of application specific data can be performed
   anytime.  The action(s) to perform after a possible failure is out of
   scope for this specification (see <a href="#section-3.2">Section 3.2</a>).

<span class="h2"><a class="selflink" name="section-6" href="#section-6">6</a>.  Common Operations</span>

   This specification builds on a modular scheme using common procedures
   described in the following subsections.

<span class="h3"><a class="selflink" name="section-6.1" href="#section-6.1">6.1</a>.  Create Signable JSON Data</span>

   Unsigned request data is now supposed to reside in "message".  To
   facilitate resilience against (legitimate) variances in JSON
   processing between different platforms and systems, "message" needs
   to be canonicalized and serialized into a UTF-8 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>] encoded
   byte array.  If the used JSON tools offer intrinsic support for JCS
   [<a href="#ref-JCS" title="&quot;JSON Canonicalization Scheme - Work in progress&quot;">JCS</a>], this is typically a single operation, else the followings
   steps are performed:

   1.  Serialize "message" using standard JSON tools for the platform.

   2.  Create a canonical and UTF-8 encoded form of the data created in
       the preceding step, through an external software solution
       supporting JCS.

   The output from JCS represents a "JWS Payload" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>].

<span class="h3"><a class="selflink" name="section-6.2" href="#section-6.2">6.2</a>.  Create Signable URI Data</span>

   For URI based requests, the steps to create signable URI data are as
   follows:

   1.  Convert "targetURI" into a UTF-8 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>] encoded byte array.

   2.  Create a digest of the result of the preceding step using the
       previously defined "hashAlgorithm".  The result is a byte array.

   3.  The result of the preceding step is subsequently Base64Url
       encoded.

   The test vectors in <a href="#appendix-A">Appendix A</a> provide a few examples showing
   authentic values of the "htu" (Hashed Target URI) property.







<span class="grey">Rundgren                Expires November 6, 2019               [Page 13]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


<span class="h3"><a class="selflink" name="section-6.3" href="#section-6.3">6.3</a>.  Create HTTP Header Object</span>

   To create a digest of headers to be included in a signed request,
   perform the following operations:

   1.  Create an empty string "headerBlob".

   2.  Create an empty string "headerList".

   3.  Create a collection of headers to be sent as described in
       <a href="#section-6.8">Section 6.8</a>.

   4.  Enumerate the "headerCollection" and perform the following steps
       for each entry:

       *  Append header field name to "headerList".

       *  Append header field name to "headerBlob".

       *  Append a semicolon (':') to to "headerBlob".

       *  Append header field value to "headerBlob".

       *  For all but the last entry, append a newline (U+000A) to
          "headerBlob".

       *  For all but the last entry, append a comma (',') to
          "headerList".

   5.  Create a two element JSON Array object "headerData".

   6.  Run the previously defined "hashAlgorithm" (see <a href="#section-6.12">Section 6.12</a>)
       over the UTF-8 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>] representation of "headerBlob".

   7.  Base64Url-encode the result of the preceding operation and assign
       the result to the first entry in "headerData" in the form of a
       JSON String.

   8.  Assign a copy of "headerList" to the second entry in "headerData"
       in the form of a JSON String.

   9.  Add a property "hdr" to ".secinf" using a copy of "headerData" as
       argument.

   Below is an example of header input data:

     x-debug: full
     Cache-Control: max-age=60, must-revalidate



<span class="grey">Rundgren                Expires November 6, 2019               [Page 14]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-15" id="page-15" href="#page-15" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   Applying the process described in this subsection and using the
   SHA-256 [<a href="#ref-SHS" title="&quot;Secure Hash Standard (SHS)&quot;">SHS</a>] hash algorithm should generate the following ".secinf"
   data:

     "hdr": ["Ljzuq8C9PScbvLpBxG8GNOs-WQUd7gl7R64izahhe-0",
             "x-debug,cache-control"]

<span class="h3"><a class="selflink" name="section-6.4" href="#section-6.4">6.4</a>.  Create JWS Protected Header</span>

   Create a "JWS Protected Header" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] JSON Object with algorithm
   and key data adapted for the application.  Below is a minimal
   example:

     {
       "alg": "ES256"
     }

<span class="h3"><a class="selflink" name="section-6.5" href="#section-6.5">6.5</a>.  Create JWS String</span>

   To create a compact JWS object (a string), perform the following
   steps:

   1.  Serialize the previously defined "JWS Protected Header" object
       into a UTF-8 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>] encoded byte array.

   2.  Base64Url-encode the output from the preceding step into a local
       variable "jwsProtectedHeaderB64U".

   3.  Base64Url-encode the previously defined variable "JWS Payload"
       into a local variable "jwsPayloadB64U".

   4.  Set a local variable "signedData" to the UTF-8 encoded
       representation of the concatenation of:

       *  The previously defined variable "jwsProtectedHeaderB64U".

       *  A point character (".").

       *  The previously defined variable "jwsPayloadB64U".

   5.  Use the designated signature key, signature algorithm and
       "signedData" to create a "JWS Signature" object (byte array).

   6.  Return the string consisting of the concatenation of:

       *  The previously defined variable "jwsProtectedHeaderB64U".

       *  A period character ('.').



<span class="grey">Rundgren                Expires November 6, 2019               [Page 15]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-16" id="page-16" href="#page-16" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


       *  For URI based requests only: "jwsPayloadB64U".  That is, JSON
          based requests use the detached JWS format described in
          <a href="http://tools.ietf.org/html//rfc7515#appendix-F">Appendix&nbsp;F of [RFC7515]</a>.

       *  A period character ('.').

       *  The previously defined variable "JWS Signature", here encoded
          in Base64Url [<a href="http://tools.ietf.org/html//rfc4648" title="&quot;The Base16, Base32, and Base64 Data Encodings&quot;">RFC4648</a>].

<span class="h3"><a class="selflink" name="section-6.6" href="#section-6.6">6.6</a>.  Decode JWS String</span>

   The following processing steps presume that there is an input string
   holding a JWS compact object, here called "jwsString":

   1.  Verify that "jwsString" has the syntax

       "header.payload.signature"

       where the length of the "payload" element is zero for JSON based
       requests and non-zero for URI based requests.  That is, JSON
       based requests use the detached JWS format described in
       <a href="http://tools.ietf.org/html//rfc7515#appendix-F">Appendix&nbsp;F of [RFC7515]</a>.

   2.  Assign the "header" portion of "jwsString" to a variable
       "jwsProtectedHeaderB64U".

   3.  Base64Url-decode "jwsProtectedHeaderB64U" into a byte array.

   4.  Parse the output from the preceding step with a JSON parser and
       assume that the result (which MUST be a JSON Object) represents a
       "JWS Protected Header" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>].

   5.  For URI based requests only:
       base64Url-decode the "payload" portion of "jwsString" into a byte
       array representing a "JWS Payload" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>].

   6.  Base64Url-decode the "signature" portion of "jwsString" into a
       byte array representing a "JWS Signature" [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>].

   If any of the steps above fail, the service MUST reject the request
   (see <a href="#section-3.2">Section 3.2</a>).

<span class="h3"><a class="selflink" name="section-6.7" href="#section-6.7">6.7</a>.  Normalize Target URI</span>

   To facilitate comparison between actual (received) URIs and signed
   URIs, URIs MUST be normalized according to the following:





<span class="grey">Rundgren                Expires November 6, 2019               [Page 16]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-17" id="page-17" href="#page-17" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


      The schema default ports 443 and 80 MUST be removed from HTTPS and
      HTTP URIs respectively.

      URI characters that have been escaped that are in the non-reserved
      set [ALPHA DIGIT '-' '.' '_' '~'] MUST be restored in their
      natural form.

      Escape sequences MUST transformed into uppercase.

      Non-ASCII characters MUST be escaped to their UTF-8 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>]
      counterpart.

      Host names MUST be lowercased.

   The following URI shows a non-normalized URI:

     <a href="https://EXAMPLE.COM:443/%63EURO%2f">https://EXAMPLE.COM:443/%63EURO%2f</a>

      Note: EURO denotes a single Euro character (Unicode: U+20AC),
      which not being ASCII, is currently not displayable in RFCs.

   The same URI after normalization:

     https://example.com/c%E2%82%AC%2F

   [[ This section is still incomplete ]]

<span class="h3"><a class="selflink" name="section-6.8" href="#section-6.8">6.8</a>.  Normalize Header Data</span>

   Headers to be included in signed requests MUST be normalized.  This
   subsection shows a common procedure for senders and receivers based
   on <a href="http://tools.ietf.org/html//rfc7230#section-3.2.4">Section&nbsp;3.2.4 of [RFC7230]</a>.

   Collect received headers or headers to be submitted in a list of
   header field name and header field value pairs according to the
   following:

   o  Header field names MUST be lowercased.

   o  Leading and trailing optional whitespace (OWS) in the header field
      value MUST be omitted.  If there are multiple instances of the
      same header field name, all header field values associated with
      the header field name MUST be concatenated, separated by an ASCII
      comma and an ASCII space (', '), and used in the order in which
      they are intended to appear in an HTTP message.  Any other
      modification to the header field value MUST NOT be made.





<span class="grey">Rundgren                Expires November 6, 2019               [Page 17]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-18" id="page-18" href="#page-18" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   This list is referred to as "headerCollection" in other places in
   this specification.

   Below is an example of header input data:

     x-debug: full
     Cache-control:  max-age=60
     Cache-Control: must-revalidate

   Applying the process described in this subsection should generate the
   following collection:

     |======================================================|
     |  Header Field Name  |      Header Field Value        |
     |======================================================|
     | x-debug             | full                           |
     |------------------------------------------------------|
     | cache-control       | max-age=60, must-revalidate    |
     |------------------------------------------------------|

   For interoperability reasons it is RECOMMENDED to not use duplicate
   header names for headers that are to be signed.  Apparently proxy
   servers do not always honor original header ordering.

<span class="h3"><a class="selflink" name="section-6.9" href="#section-6.9">6.9</a>.  Validate HTTP Header Object</span>

   To validate a digest of headers in a signed request, perform the
   following operations:

   1.  Create a collection of received headers as described in
       <a href="#section-6.8">Section 6.8</a>.

   2.  Create an empty string "headerBlob".

   3.  Read the "hdr" property of ".secinf".  This MUST be a JSON Array
       holding exactly two JSON String elements.

   4.  Perform the following actions on the data obtained in the
       preceding step:

       *  Base64Url-decode the first string into a byte array "digest".

       *  Split the second string into ordered array of strings called
          "headerList".  Note that the format MUST be a list of header
          field names in lowercase, separated by comma (',') characters.
          There MUST NOT be any whitespace or terminating comma in this
          string.




<span class="grey">Rundgren                Expires November 6, 2019               [Page 18]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-19" id="page-19" href="#page-19" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


       *  Verify that the received "headerList" contains the header
          field names as defined by an application specific policy.

   5.  Enumerate the "headerList" and perform the following steps for
       each entry:

       *  Append header field name to "headerBlob".

       *  Append a semicolon (':') to to "headerBlob".

       *  Retrieve the matching header field value from
          "headerCollection".

       *  Append the result of the preceding step to "headerBlob".

       *  For all but the last entry, append a newline (U+000A) to
          "headerBlob".

   6.  Run the previously defined "hashAlgorithm" (see <a href="#section-6.12">Section 6.12</a>)
       over the UTF-8 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>] representation of "headerBlob".

   7.  Verify that the result of the preceding step is identical to
       "digest".

   If any of the steps above fail, the service MUST reject the request
   (see <a href="#section-3.2">Section 3.2</a>).

   Note that this specification does not enforce any particular ordering
   of signed header elements.

<span class="h3"><a class="selflink" name="section-6.10" href="#section-6.10">6.10</a>.  Validate JWS Signature</span>

   Validation of the JWS [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] object, using the previously
   extracted and decoded objects requires the following steps:

   1.  Verify that the received "JWS Protected Header" contains a JWS
       algorithm ("alg") and key identifiers that matches the needs of
       the application.

   2.  Retrieve the signature validation key.  This part is application
       specific since the key may be implicit, specified by a key ID
       ("kid") or be supplied in a certificate path ("x5c").

   3.  Set a local variable "signedData" to the UTF-8 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>] encoded
       representation of the string created by concatenating the
       following elements:

       *  The previously collected variable "jwsProtectedHeaderB64U".



<span class="grey">Rundgren                Expires November 6, 2019               [Page 19]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-20" id="page-20" href="#page-20" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


       *  A period character ('.').

       *  The previously collected variable "JWS Payload", but here
          encoded in Base64Url [<a href="http://tools.ietf.org/html//rfc4648" title="&quot;The Base16, Base32, and Base64 Data Encodings&quot;">RFC4648</a>].

   4.  Validate the signature using the algorithm retrieved in step 1,
       the signature validation key from step 2, "signedData" from step
       3 and the previously collected "JWS Signature" object (byte
       array).

   If any of the steps above fail, the service MUST reject the request
   (see <a href="#section-3.2">Section 3.2</a>).

<span class="h3"><a class="selflink" name="section-6.11" href="#section-6.11">6.11</a>.  Time Stamps</span>

   Time stamps have the same name ("iat"), format and function as
   described in JWT <a href="http://tools.ietf.org/html//rfc7519#section-4.1.6">[RFC7519], Section&nbsp;4.1.6</a>.  However, in this
   specification time stamps are REQUIRED, and stored in the ".secinf"
   JSON Object.

   Although JWT permits non-integer values, implementers of this
   specification SHOULD limit generated time stamp granularity to
   seconds and use integer representation.

   The policy with respect to the difference between the current time
   and received time stamps is out of scope for this specification.
   However, for security reasons it is generally a good idea limiting
   deviations to a few minutes as well as using network based clock
   synchronization in both ends.

<span class="h3"><a class="selflink" name="section-6.12" href="#section-6.12">6.12</a>.  Hash Algorithms</span>

   Inclusion of HTTP header elements as well as the "htu" property of
   URI based requests depends on digests produced by a hash algorithm.
   The default is using the hash algorithm associated with the JWS
   signature algorithm ("alg") featured in the "JWS Protected Header".
   That is, the JWA [<a href="http://tools.ietf.org/html//rfc7518" title="&quot;JSON Web Algorithms (JWA)&quot;">RFC7518</a>] algorithms "ES256" and "HS384" imply the
   hash algorithms SHA-256 and SHA-384 respectively.

   In case this is not desired, this specification permits overriding
   the default by including a "hao" (Hash Algorithm Override) property
   in the ".secinf" JSON Object.  The currently recognized arguments to
   "hao" are:

      "S256" for SHA-256 [<a href="#ref-SHS" title="&quot;Secure Hash Standard (SHS)&quot;">SHS</a>]

      "S384" for SHA-384 [<a href="#ref-SHS" title="&quot;Secure Hash Standard (SHS)&quot;">SHS</a>]




<span class="grey">Rundgren                Expires November 6, 2019               [Page 20]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-21" id="page-21" href="#page-21" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


      "S512" for SHA-512 [<a href="#ref-SHS" title="&quot;Secure Hash Standard (SHS)&quot;">SHS</a>]

<span class="h2"><a class="selflink" name="section-7" href="#section-7">7</a>.  Local Naming Conventions</span>

   Although using the ".secinf" JSON property name and ".jws" query
   component name is RECOMMENDED, this specification permits (=being
   considered as compatible), the use of local naming conventions as
   long as the specified procedures and formats are adhered to.

   Local naming conventions MUST be properly communicated in the
   community using them.

<span class="h2"><a class="selflink" name="section-8" href="#section-8">8</a>.  MIME Multipart Requests</span>

   [[

      It should be possible to extending the JSON based request to also
      support attachments.  This is currently out of scope for this
      specification.

      An alternative to attachments is featuring such data in Base64Url
      encoded fields.

      Recently, time-limited, "cloud" based schemes using URLs with
      hard-to-guess nonce values has become a viable method for
      transferring other data.

   ]]

<span class="h2"><a class="selflink" name="section-9" href="#section-9">9</a>.  IANA Considerations</span>

   This document currently has no IANA actions but the reserved names
   below could be candidates for IANA registration:

   .secinf
      JSON Object holding the security related data of this
      specification.

   .jws
      HTTP query component holding the security related data of this
      specification.

   The hash algorithms defined in <a href="#section-6.12">Section 6.12</a> could also benefit from
   IANA registration.







<span class="grey">Rundgren                Expires November 6, 2019               [Page 21]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-22" id="page-22" href="#page-22" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


<span class="h2"><a class="selflink" name="section-10" href="#section-10">10</a>.  Security Considerations</span>

   The purpose of this specification is adding an integrity and
   authorization layer to HTTP requests.  This part is subject to the
   same security considerations as the underpinning JCS and JWS schemes.

   For most applications HTTPS [<a href="http://tools.ietf.org/html//rfc7231" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content&quot;">RFC7231</a>] would be the logical choice,
   not only for protecting application data from snooping, but also to
   not unnecessary reveal data about signature keys.

   In a cloud scenario with Web servers open for access by any party new
   security challenges are introduced.  Cryptographic solutions protect
   data but may also add vulnerabilities to denial-of-service attacks
   since they often need substantial processing.

   Protecting against replay attacks is important because replay may
   actually be a legitimate facility for systems repeating a request due
   to a communication failure.  This cannot be entirely solved by time
   stamps and cryptography; you usually need unique transactions IDs and
   data base support as well.  For reliable operation there must be
   common rules within a community using such features.  The REST [<a href="#ref-REST" title="&quot;Architectural Styles and the Design of Network-based Software Architectures&quot;">REST</a>]
   paradigm also requires such measures due to the idempotent operation
   specified for "PUT", "GET" and "DELETE.

<span class="h2"><a class="selflink" name="section-11" href="#section-11">11</a>.  Acknowledgements</span>

   Parts of this specification were derived from the HTTP signature
   [<a href="#ref-HTTPSIG" title="&quot;Signing HTTP Messages&quot;">HTTPSIG</a>] draft.

<span class="h2"><a class="selflink" name="section-12" href="#section-12">12</a>.  References</span>

<span class="h3"><a class="selflink" name="section-12.1" href="#section-12.1">12.1</a>.  Normative References</span>

   [<a name="ref-JCS" id="ref-JCS">JCS</a>]      A. Rundgren, B. Jordan, S. Erdtman, "JSON Canonicalization
              Scheme - Work in progress", &lt;<a href="https://tools.ietf.org/html/draft-rundgren-json-canonicalization-scheme-05">https://tools.ietf.org/html/</a>
              <a href="https://tools.ietf.org/html/draft-rundgren-json-canonicalization-scheme-05">draft-rundgren-json-canonicalization-scheme-05</a>&gt;.

   [<a name="ref-JWSJCS" id="ref-JWSJCS">JWSJCS</a>]   A. Rundgren, "Combined JWS and JCS Signature Scheme - Work
              in progress", &lt;<a href="https://github.com/cyberphone/jws-jcs">https://github.com/cyberphone/jws-jcs</a>&gt;.

   [<a name="ref-RFC2119" id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="http://tools.ietf.org/html//bcp14">BCP 14</a>, <a href="http://tools.ietf.org/html//rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.







<span class="grey">Rundgren                Expires November 6, 2019               [Page 22]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-23" id="page-23" href="#page-23" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   [<a name="ref-RFC3986" id="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              <a href="http://tools.ietf.org/html//rfc3986">RFC 3986</a>, DOI 10.17487/RFC3986, January 2005,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;.

   [<a name="ref-RFC4648" id="ref-RFC4648">RFC4648</a>]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", <a href="http://tools.ietf.org/html//rfc4648">RFC 4648</a>, DOI 10.17487/RFC4648, October 2006,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;.

   [<a name="ref-RFC7230" id="ref-RFC7230">RFC7230</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              <a href="http://tools.ietf.org/html//rfc7230">RFC 7230</a>, DOI 10.17487/RFC7230, June 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.

   [<a name="ref-RFC7231" id="ref-RFC7231">RFC7231</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", <a href="http://tools.ietf.org/html//rfc7231">RFC 7231</a>,
              DOI 10.17487/RFC7231, June 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.

   [<a name="ref-RFC7493" id="ref-RFC7493">RFC7493</a>]  Bray, T., Ed., "The I-JSON Message Format", <a href="http://tools.ietf.org/html//rfc7493">RFC 7493</a>,
              DOI 10.17487/RFC7493, March 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7493">https://www.rfc-editor.org/info/rfc7493</a>&gt;.

   [<a name="ref-RFC7515" id="ref-RFC7515">RFC7515</a>]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", <a href="http://tools.ietf.org/html//rfc7515">RFC 7515</a>, DOI 10.17487/RFC7515, May
              2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7515">https://www.rfc-editor.org/info/rfc7515</a>&gt;.

   [<a name="ref-RFC7518" id="ref-RFC7518">RFC7518</a>]  Jones, M., "JSON Web Algorithms (JWA)", <a href="http://tools.ietf.org/html//rfc7518">RFC 7518</a>,
              DOI 10.17487/RFC7518, May 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7518">https://www.rfc-editor.org/info/rfc7518</a>&gt;.

   [<a name="ref-RFC7519" id="ref-RFC7519">RFC7519</a>]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web Token
              (JWT)", <a href="http://tools.ietf.org/html//rfc7519">RFC 7519</a>, DOI 10.17487/RFC7519, May 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7519">https://www.rfc-editor.org/info/rfc7519</a>&gt;.

   [<a name="ref-RFC8174" id="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in <a href="http://tools.ietf.org/html//rfc2119">RFC</a>
              <a href="http://tools.ietf.org/html//rfc2119">2119</a> Key Words", <a href="http://tools.ietf.org/html//bcp14">BCP 14</a>, <a href="http://tools.ietf.org/html//rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a name="ref-RFC8259" id="ref-RFC8259">RFC8259</a>]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, <a href="http://tools.ietf.org/html//rfc8259">RFC 8259</a>,
              DOI 10.17487/RFC8259, December 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8259">https://www.rfc-editor.org/info/rfc8259</a>&gt;.

   [<a name="ref-SHS" id="ref-SHS">SHS</a>]      National Institute of Standards and Technology, "Secure
              Hash Standard (SHS)", FIPS PUB 180-4, August 2015,
              &lt;<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">https://nvlpubs.nist.gov/nistpubs/FIPS/</a>
              <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">NIST.FIPS.180-4.pdf</a>&gt;.



<span class="grey">Rundgren                Expires November 6, 2019               [Page 23]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-24" id="page-24" href="#page-24" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   [<a name="ref-UNICODE" id="ref-UNICODE">UNICODE</a>]  The Unicode Consortium, "The Unicode Standard, Version
              10.0.0",
              &lt;<a href="https://www.unicode.org/versions/Unicode10.0.0/">https://www.unicode.org/versions/Unicode10.0.0/</a>&gt;.

<span class="h3"><a class="selflink" name="section-12.2" href="#section-12.2">12.2</a>.  Informal References</span>

   [<a name="ref-AWS" id="ref-AWS">AWS</a>]      Amazon.com, "Signing AWS API Requests",
              &lt;<a href="https://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html">https://docs.aws.amazon.com/general/latest/gr/</a>
              <a href="https://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html">signing_aws_api_requests.html</a>&gt;.

   [<a name="ref-FAPI" id="ref-FAPI">FAPI</a>]     Open ID, "Financial-grade API",
              &lt;<a href="https://openid.net/wg/fapi/">https://openid.net/wg/fapi/</a>&gt;.

   [<a name="ref-HTTPSIG" id="ref-HTTPSIG">HTTPSIG</a>]  M. Cavage, M. Sporny, "Signing HTTP Messages",
              &lt;<a href="https://tools.ietf.org/html/draft-cavage-http-signatures-10">https://tools.ietf.org/html/</a>
              <a href="https://tools.ietf.org/html/draft-cavage-http-signatures-10">draft-cavage-http-signatures-10</a>&gt;.

   [<a name="ref-OBIE" id="ref-OBIE">OBIE</a>]     Open Banking UK, "Open Banking API",
              &lt;<a href="https://www.openbanking.org.uk/">https://www.openbanking.org.uk/</a>&gt;.

   [<a name="ref-REST" id="ref-REST">REST</a>]     Roy Fielding, "Architectural Styles and the Design of
              Network-based Software Architectures",
              &lt;<a href="http://roy.gbiv.com/pubs/dissertation/top.htm">http://roy.gbiv.com/pubs/dissertation/top.htm</a>&gt;.

   [<a name="ref-STET" id="ref-STET">STET</a>]     STET, "PSD2 API V1.4.1", &lt;<a href="https://www.stet.eu/en/psd2/">https://www.stet.eu/en/psd2/</a>&gt;.

<span class="h3"><a class="selflink" name="section-12.3" href="#section-12.3">12.3</a>.  URIs</span>

   [<a name="ref-1" id="ref-1">1</a>] <a href="https://github.com/cyberphone/ietf-signed-http-requests">https://github.com/cyberphone/ietf-signed-http-requests</a>

<span class="h2"><a class="selflink" name="appendix-A" href="#appendix-A">Appendix A</a>.  Test Vectors</span>

   The following test vectors "activate" all parts of the specification.
   After removing the line breaks needed for publishing, the test
   vectors are supposed to be fully validatable.

<span class="h3"><a class="selflink" name="appendix-A.1" href="#appendix-A.1">A.1</a>.  Type=URI, Method=GET, Algorithm=HS256</span>

   Target URI:

     https://example.com/users/456

   Signed URI:

     https://example.com/users/456?.jws=eyJhbGciOiJIUzI1NiJ9.eyJodHUi
     OiJmaVZpNGpZaER0N1ZDdVFJS1VJZFdJTkVXZm9oX05YSGZMVFpORWVTYXZZIiwi
     aWF0IjoxNTUxOTUxOTAwfQ.Wll5cFEE9sidHs01sADus8kbHNHAC5DCzyytYoAtT
     2g



<span class="grey">Rundgren                Expires November 6, 2019               [Page 24]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-25" id="page-25" href="#page-25" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


   Decoded JWS Payload:

     {
       "htu": "fiVi4jYhDt7VCuQIKUIdWINEWfoh_NXHfLTZNEeSavY",
       "iat": 1551951900
     }

   Symmetric signature validation key, here in hexadecimal notation:

     7fdd851a3b9d2dafc5f0d00030e22b9343900cd42ede4948568a4a2ee655291a

<span class="h3"><a class="selflink" name="appendix-A.2" href="#appendix-A.2">A.2</a>.  Type=JSON, Method=POST, Algorithm=ES256</span>

   Target URI:

     https://example.com/users

   JSON Body:

     {
       "name": "John Doe",
       "profession": "Unknown",
       ".secinf": {
         "uri": "https://example.com/users",
         "iat": 1551951900,
         "jws": "eyJhbGciOiJFUzI1NiJ9..-N7yuF1TEASo5Ub5q2T1_EkLWrWHs2
     nyHjDupkinoRcQbSo8h2ygL9pmGzd_YU4jn_bcMQF8BrTIlSioNel5GQ"
       }
     }

   Public signature validation key, here in PEM format:

     -----BEGIN PUBLIC KEY-----
     MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEcensDzcMEkgiePz6DXB7cDuwFems
     hAFR90UNVQFCg8TGryvN7p7AbT55VxIXvYnvuAqIPQgefOnAdpTu3qdV5g==
     -----END PUBLIC KEY-----

<span class="h3"><a class="selflink" name="appendix-A.3" href="#appendix-A.3">A.3</a>.  Type=JSON, Method=PUT, Algorithm=ES256</span>

   Target URI:

     https://example.com/users/456

   JSON Body:







<span class="grey">Rundgren                Expires November 6, 2019               [Page 25]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-26" id="page-26" href="#page-26" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


     {
       "name": "Jane Smith",
       "profession": "Hacker",
       ".secinf": {
         "uri": "https://example.com/users/456",
         "mtd": "PUT",
         "iat": 1551951900,
         "jws": "eyJhbGciOiJFUzI1NiJ9.._VWTXYcgr6OTCcJg6XZzPkHsLU-jUT
     T1HoQ92bihMIDlXR7xNfmxlHWSUc9cyFCxzsBy9yq33eFn3fApIH42SA"
       }
     }

   Public signature validation key, here in PEM format:

     -----BEGIN PUBLIC KEY-----
     MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEcensDzcMEkgiePz6DXB7cDuwFems
     hAFR90UNVQFCg8TGryvN7p7AbT55VxIXvYnvuAqIPQgefOnAdpTu3qdV5g==
     -----END PUBLIC KEY-----

<span class="h3"><a class="selflink" name="appendix-A.4" href="#appendix-A.4">A.4</a>.  Type=URI, Method=DELETE, Algorithm=RS256</span>

   Target URI:

     https://example.com/users/456

   Signed URI:

     https://example.com/users/456?.jws=eyJhbGciOiJSUzI1NiJ9.eyJodHUi
     OiI5R3FtRDBSRWRqSDFZNklvSXR3UjdKRURuU0pjVzNuSnhoM085eHQ3Zk1RQ1cy
     N3FtOEQyWUNtN1h4RzRwU1hwOGJFM3lTT3RzWlhIR0VJSWw1M05jQSIsIm10ZCI6
     IkRFTEVURSIsImlhdCI6MTU1MTk1MTkwMCwiaGFvIjoiUzUxMiIsImhkciI6WyIz
     ZXBrQno4RUJwMUxYX01EdFd1WnFWZjFLYjJyalFNZzE5RjVvT2Fhbk91SVFpS1Z1
     SHBrSG5WdWFLMlZZbVZ2bEpOSGxEY2NEeHFxVGQxNFU5VXg5USIsIngtZGVidWci
     XX0.YRTEbCrOy11c10HcPSDX_DCtl56S5qmcYWFcuG6wqsgg7vnCr22vCDhE1xJL
     xeM2hp_-gSmdxykJ-Q060xetax-nMmXUhrDtcRoeCfO12-xDTymZTJXtb11SX6Pn
     mt9CnM4ZOVrJVro7eLW8hCc4p5As7zDS2arNM_-IsWiNJ1T25EDb8ZS7kLLSA6Im
     lo31o8815kC0oHNI0q-lZeaOX3DhnL1tMJKZQzrItXvmZ0oqJ3kL8bxF6aglOFC0
     zOYUU2kciIf55jVcfBgwupecFw-rN56QEg8PzA8YA-nGPWHBpxJUWWseY4qXZudR
     cQQZtms7Yc1yK7z3fNhht6Oh1A

   Decoded JWS Payload:










<span class="grey">Rundgren                Expires November 6, 2019               [Page 26]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-27" id="page-27" href="#page-27" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


     {
       "htu": "9GqmD0REdjH1Y6IoItwR7JEDnSJcW3nJxh3O9xt7fMQCW27qm8D2YC
     m7XxG4pSXp8bE3ySOtsZXHGEIIl53NcA",
       "mtd": "DELETE",
       "iat": 1551951900,
       "hao": "S512",
       "hdr": ["3epkBz8EBp1LX_MDtWuZqVf1Kb2rjQMg19F5oOaanOuIQiKVuHpkH
     nVuaK2VYmVvlJNHlDccDxqqTd14U9Ux9Q", "x-debug"]
     }

   Note the overridden hash algorithm.

   Required HTTP Headers:

     x-debug: full

   Public signature validation key, here in PEM format:

     -----BEGIN PUBLIC KEY-----
     MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAhFWEXArvaZEpSP5qNX7x
     4C4Hl28GJQTNvnDwkfqiWs63kXbdyPeS06bz6GnY3tfQ/093nGauWsimqKBmGAGM
     PtsV83Qxw1OIeO4ujbIIb9pema0qtVqs0MWlHxklZGFkYfAmbuEUFxYDeLDHe0bk
     kXbSlB7/t8pCSvc8HLgHjEQjYOlFRwjR0D+uLo+xgsCbpmCtYkB5lcT/zFgpRgY4
     zJNLSv7GZiz2S4Fc5ArGjd34lL47+L8bozuYjqNOv9sqX0Zgll5XaJ1ndvr7UqZu
     1xQFgm38reoM3IarBP/SkEFbt/v9iak602VO3k28fQhMaocP7JWR2YLT3kZM0+WT
     FwIDAQAB
     -----END PUBLIC KEY-----

<span class="h2"><a class="selflink" name="appendix-B" href="#appendix-B">Appendix B</a>.  Other Signed HTTP Request Solutions</span>

   This appendix briefly outlines a few other solutions addressing
   Signed HTTP Requests.

<span class="h3"><a class="selflink" name="appendix-B.1" href="#appendix-B.1">B.1</a>.  Amazon Web Services</span>

   AWS provides a system for their clients using HTTP headers holding
   security constructs while the digested HTTP body may hold any valid
   media type.  For more information see the [<a href="#ref-AWS" title="&quot;Signing AWS API Requests&quot;">AWS</a>].  Signatures may also
   be added to query strings in a similar fashion to <a href="#section-5">Section 5</a>.

<span class="h3"><a class="selflink" name="appendix-B.2" href="#appendix-B.2">B.2</a>.  HTTP Signatures</span>

   HTTP Signatures is a system using HTTP headers holding security
   constructs while the (optional) digested HTTP body may hold any valid
   media type.  This scheme has been adopted by the French Open Banking
   API [<a href="#ref-STET" title="&quot;PSD2 API V1.4.1&quot;">STET</a>].  For more information see the Internet draft [<a href="#ref-HTTPSIG" title="&quot;Signing HTTP Messages&quot;">HTTPSIG</a>].
   HTTP Signatures also supports signed response data.




<span class="grey">Rundgren                Expires November 6, 2019               [Page 27]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-28" id="page-28" href="#page-28" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


<span class="h3"><a class="selflink" name="appendix-B.3" href="#appendix-B.3">B.3</a>.  Open Banking (UK)</span>

   The current (3.1) version of the Open Banking API [<a href="#ref-OBIE" title="&quot;Open Banking API&quot;">OBIE</a>] use a scheme
   where a dedicated HTTP header holds a detached JWS signature covering
   a clear text JSON message in the HTTP body:

     POST /foo HTTP/1.1
     Host: example.com
     Content-Type: application/json
     x-jws-signature: eyJhbGciOiJSUzI1N..SD7xMbpL-2QgwUsAlMGzw
     Content-Length: 2765

     {
        "something": "data",

            Additional application specific properties

     }

   Notes:

   o  The HTTP URI, method and headers are unsigned.

   o  The signature argument (a JWS) was truncated for brevity.

<span class="h3"><a class="selflink" name="appendix-B.4" href="#appendix-B.4">B.4</a>.  Financial API</span>

   The current version (Draft 06) of the financial API [<a href="#ref-FAPI" title="&quot;Financial-grade API&quot;">FAPI</a>] use a
   scheme where the payload is signed using JWS in Base64Url mode:

     POST /foo HTTP/1.1
     Host: example.com
     Content-Type: application/jws
     Content-Length: 1288

     eyJhbGcRjIn0.ew0KICJfds56gty5ypc3MiOiA.2QgwUsA565656lMGzw

   Notes:

   o  The HTTP URI, method and headers are unsigned.

   o  The JWS signature was truncated for brevity.

<span class="h2"><a class="selflink" name="appendix-C" href="#appendix-C">Appendix C</a>.  Development Portal</span>

   The SHREQ specification is currently developed at:
   <a href="https://github.com/cyberphone/ietf-signed-http-requests">https://github.com/cyberphone/ietf-signed-http-requests</a> [<a href="#ref-1">1</a>].




<span class="grey">Rundgren                Expires November 6, 2019               [Page 28]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-29" id="page-29" href="#page-29" class="invisible"> </a>
<span class="grey">Internet-Draft     <a href="http://tools.ietf.org/html//draft-rundgren-signed-http-requests">draft-rundgren-signed-http-requests</a>          May 2019</span>


Author's Address

   Anders Rundgren
   Independent
   Montpellier
   France

   Email: anders.rundgren.net@gmail.com
   URI:   <a href="https://www.linkedin.com/in/andersrundgren/">https://www.linkedin.com/in/andersrundgren/</a>










































Rundgren                Expires November 6, 2019               [Page 29]

</pre><br />
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
</body>
</html>
