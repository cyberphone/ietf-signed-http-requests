<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" docName="draft-rundgren-signed-rest-for-json-00" ipr="trust200902">
  <front>
    <title abbrev="draft-rundgren-signed-rest-for-json">
      Signed REST for JSON (SIGREST)
    </title>

    <author fullname="Anders Rundgren" initials="A." surname="Rundgren">
      <organization>Independent</organization>
      <address>
        <postal>
          <street></street>
          <code></code>
          <city>Montpellier</city>
          <country>France</country>
        </postal>
        <email>anders.rundgren.net@gmail.com</email>
        <uri>https://www.linkedin.com/in/andersrundgren/</uri>
      </address>
    </author>

    <date year="2019" />

    <area>Security</area>

    <workgroup></workgroup>

    <keyword>
      HTTP, JSON, Canonicalization, Signatures
    </keyword>

    <abstract>
      <t>
        This specification describes how JCS <xref target="JCS"/>
        combined with JWS <xref target="RFC7515"/>,
        can be utilized to support REST <xref target="REST"/> applications
        needing digitally signed requests. The described scheme is
        tailored for Web applications using JSON <xref target="RFC8259"/>
        as message format.
      </t>
      <t>
        The intended audiences of this document are Web tool vendors, as
        well as designers of secure Web applications.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
      <t>
        Currently there is no standard for digitally signing REST <xref target="REST"/>
        requests.  This has lead to the development of several proprietary solutions (see <xref target="other.solutions"/>)
        typically building on using HTTP header data for holding security constructs,
        while JSON request data is provided in clear in the HTTP body.
      </t>
      <t>
        This specification is intended to provide a standardized alternative that
        fully honors the REST concept without (directly) using HTTP headers for holding
        security constructs.  That is, JSON message data is supposed to also hold
        the security portion of a message.  This arrangement has the following characteristics:
        <list style="symbols">
          <t>
            Since REST requests (as a minimum) also are defined by HTTP URI and HTTP Verb
            these attributes are added as reserved JSON properties to signed request data.
          </t>
          <t>
            Due to the fact that messages compliant with this specification constitute of self-contained JSON objects,
            they may be serialized in databases or be embedded in other JSON objects.  The latter includes
            supporting counter signatures.
          </t>
          <t>
            The use of canonicalization provided by JCS makes signatures remain valid
            also after being processed by arbitrary JSON compliant tools.
          </t>
          <t>
            JWS is used in detached mode without modifications or extensions. 
          </t>
          <t>
            For general interoperability concerns as well as due to the relyiance on JCS,
            JSON message data is limitied to the I&nbhy;JSON <xref target="RFC7493"/> subset. 
          </t>
        </list>
        The above applies to REST requests using the HTTP methods POST, PUT or PATCH.
        For REST requests using the HTTP methods GET or DELETE, another entirely URI based
        scheme is described which also depends on JWS in detached mode for security.
      </t>
    </section>

    <section anchor="Terminology" title="Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>

    <section anchor="rest.operation" title="Detailed Operation">
      <t>
        Assume you want to compare productions of JSON data where the schema
        designer assigned the property "big" for holding a "BigInteger" subtype and
        "time" for holding a "DateTime" subtype, while "val" is supposed to be a JSON Number
        compliant with JCS. The following example shows such an object:
      </t>
      <section anchor="rest.operation.withbody" title="Methods: POST, PUT and PATCH">
        <t>
          <figure align="center"><artwork><![CDATA[  {
    "time": "2019-01-28T07:45:10Z",
    "big": "055", 
    "val": 3.5
  }]]>
            </artwork>
          </figure>
        </t>
      </section>
    <section anchor="rest.operation.urionly" title="Methods: GET and DELETE">
      <t>
        A problem here is that "055" clearly is not a canonical form for a "BigInteger"
        while a "DateTime" object like "2019-01-28T07:45:10Z"
        might as well be expressed as "2019-01-28T08:45:10.000+01:00" making
        comparisons based on JCS canonicalization fail.
      </t>
      <t>
        To resolve this issue using JCS the following measures MUST be taken:
        <list style="symbols">
          <t>
            The community or standard utilizing a specific JSON schema
            defines a strict normalized form for each of the used subtypes.
          </t>
          <t>
            Compatible serializers are created for each subtype.
          </t>
        </list>
        A positive side effect of this arrangement is that it enforces strict definitions
        of subtypes which improves interoperability in general as well.
      </t>
      <t>
        Defining specific subtypes and their normalized form is out of scope for
        this application note.  Although the JSON example illustrated a "BigInteger" in
        decimal notation, applications transferring huge integers
        (like raw RSA keys) typically rather use Base64 <xref target="RFC4648"/>
        encoding to conserve space.
      </t>
      <t>
        Below is an example of a strict serializer expressed in 
        for a "DateTime" subtype:
      </t>
        <t>
          <figure align="center"><artwork><![CDATA[  Date.prototype.toJSON = function() {
      let date = this.toISOString();
      // In this particular case an ISO/UTC notation was selected
      // yyyy-mm-ddThh:mm:ssZ
      return date.substring(0, date.indexOf('.')) + 'Z';
  };]]></artwork></figure>
        </t>
      </section>
      </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>
        This document has no IANA actions.
      </t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
        Systems implementing this application note are subject
        to the same security considerations as JCS and JWS.
      </t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        TBD.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.8259'?>
      <?rfc include='reference.RFC.7515'?>
      <?rfc include='reference.RFC.8174'?>
      <?rfc include='reference.RFC.7493'?>
      <reference anchor="JCS" target="https://tools.ietf.org/html/draft-rundgren-json-canonicalization-scheme-05">
        <front>
          <title>JSON Canonicalization Scheme - Work in progress</title>
          <author>
            <organization>A. Rundgren, B. Jordan, S. Erdtman</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <references title="Informal References">
      <?rfc include='reference.RFC.4648'?>
      <reference anchor="REST" target="http://roy.gbiv.com/pubs/dissertation/top.htm">
        <front>
          <title>Architectural Styles and the Design of Network-based Software Architectures</title>
          <author>
            <organization>Roy Fielding</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <section anchor="other.solutions" title="Other Signed REST Solutions">
      <t>
        Systems implementing this application note are subject
        to the same security considerations as JCS and JWS.
      </t>
    </section>
  </back>
</rfc>
