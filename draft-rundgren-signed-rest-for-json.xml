<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" docName="draft-rundgren-signed-rest-for-json-00" ipr="trust200902">
  <front>
    <title abbrev="draft-rundgren-signed-rest-for-json">
      Signed REST for JSON (SIGREST)
    </title>

    <author fullname="Anders Rundgren" initials="A." surname="Rundgren">
      <organization>Independent</organization>
      <address>
        <postal>
          <street></street>
          <code></code>
          <city>Montpellier</city>
          <country>France</country>
        </postal>
        <email>anders.rundgren.net@gmail.com</email>
        <uri>https://www.linkedin.com/in/andersrundgren/</uri>
      </address>
    </author>

    <date year="2019" />

    <area>Security</area>

    <workgroup></workgroup>

    <keyword>
      HTTP, JSON, Canonicalization, Signatures
    </keyword>

    <abstract>
      <t>
        This specification describes how JCS <xref target="JCS"/>
        combined with JWS <xref target="JWS"/>,
        can be utilized to support REST <xref target="REST"/> applications
        needing digitally signed requests. The described scheme is
        exclusively tailored for Web applications using JSON <xref target="REST"/>
        as message format.
      </t>
      <t>
        The intended audiences of this document are Web tool vendors, as
        well as designers of secure Web applications.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
      <t>
        Currently there is no standard for digitally signing REST <xref target="JCS"/>
        requests.  This has lead to the development of several propriatary solutions (see <xref target="OTHER"/>)
        typically building on using HTTP header data for holding security constructs,
        while JSON request data is provided in clear in the HTTP body.
      </t>
      <t>
        This specification is intended to provide a standardized alternative that
        fully honors the REST concept without (directly) using HTTP headers for holding
        security constructs.  That is, JSON message data is supposed to also hold
        the security portion of a message.  This arrangement has the following characteristics:
        <list>
          <t>
            Since REST requests (as a minimum) also are defined by HTTP URI and HTTP Verb
            these attributes are added as reserved JSON properties to signed request data.
          </t>
          <t>
            Since messages are self-contained JSON objectes they may be serialized in databases
            or be embedded in other JSON objects.
          </t>
          <t>
            The use of canonicalization provided by JCS makes signatures remain valid
            also after being processed by arbitrary JSON compliant tools.
          </t>
          <t>
            JWS is used in detached mode without any modifications. 
          </t>
        </list>
        The above applies to REST requests using the HTTP methods POST, PUT or PATCH.
        For REST requests using the HTTP methods GET or DELETE, another entirely URI based
        scheme is described which also depends on JWS in detached mode for security.
      </t>
    </section>

    <section anchor="Terminology" title="Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>

    <section anchor="string.subtypes" title="String Subtype Normalization">
      <t>
        Assume you want to compare productions of JSON data where the schema
        designer assigned the property "big" for holding a "BigInteger" subtype and
        "time" for holding a "DateTime" subtype, while "val" is supposed to be a JSON Number
        compliant with JCS. The following example shows such an object:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  {
    "time": "2019-01-28T07:45:10Z",
    "big": "055", 
    "val": 3.5
  }]]></artwork></figure>
      </t>
      <t>
        A problem here is that "055" clearly is not a canonical form for a "BigInteger"
        while a "DateTime" object like "2019-01-28T07:45:10Z"
        might as well be expressed as "2019-01-28T08:45:10.000+01:00" making
        comparisons based on JCS canonicalization fail.
      </t>
      <t>
        To resolve this issue using JCS the following measures MUST be taken:
        <list style="symbols">
          <t>
            The community or standard utilizing a specific JSON schema
            defines a strict normalized form for each of the used subtypes.
          </t>
          <t>
            Compatible serializers are created for each subtype.
          </t>
        </list>
        A positive side effect of this arrangement is that it enforces strict definitions
        of subtypes which improves interoperability in general as well.
      </t>
      <t>
        Defining specific subtypes and their normalized form is out of scope for
        this application note.  Although the JSON example illustrated a "BigInteger" in
        decimal notation, applications transferring huge integers
        (like raw RSA keys) typically rather use Base64 <xref target="RFC4648"/>
        encoding to conserve space.
      </t>
      <t>
        Below is an example of a strict serializer expressed in ECMAScript <xref target="ECMASCRIPT"/> 
        for a "DateTime" subtype:
      </t>
        <t>
          <figure align="center"><artwork><![CDATA[  Date.prototype.toJSON = function() {
      let date = this.toISOString();
      // In this particular case an ISO/UTC notation was selected
      // yyyy-mm-ddThh:mm:ssZ
      return date.substring(0, date.indexOf('.')) + 'Z';
  };]]></artwork></figure>
        </t>
      </section>
 
    <section anchor="IANA" title="IANA Considerations">
      <t>
        This document has no IANA actions.
      </t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
        Systems implementing this application note are subject
        to the same security considerations as JCS.
      </t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        This document was created based on feedback (on JCS) from many people
        including Mark&nbsp;Nottingham and Jim&nbsp;Schaad.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.8259'?>
      <?rfc include='reference.RFC.8174'?>
      <?rfc include='reference.RFC.7493'?>
      <reference anchor="JCS" target="https://tools.ietf.org/html/draft-rundgren-json-canonicalization-scheme-05">
        <front>
          <title>JSON Canonicalization Scheme - Work in progress</title>
          <author>
            <organization>A. Rundgren, B. Jordan, S. Erdtman</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <references title="Informal References">
      <?rfc include='reference.RFC.4648'?>
      <reference anchor="ECMASCRIPT" target="https://www.ecma-international.org/ecma-262/6.0/index.html">
        <front>
          <title>ECMAScript 2015 Language Specification</title>
          <author>
            <organization>Ecma International</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
  </back>
</rfc>
