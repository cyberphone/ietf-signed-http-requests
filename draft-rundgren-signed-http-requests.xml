<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" docName="draft-rundgren-signed-http-requests-00" ipr="trust200902">
  <front>
    <title abbrev="draft-rundgren-signed-http-requests">
      Signed HTTP Requests (SHREQ)
    </title>

    <author fullname="Anders Rundgren" initials="A." surname="Rundgren">
      <organization>Independent</organization>
      <address>
        <postal>
          <street></street>
          <code></code>
          <city>Montpellier</city>
          <country>France</country>
        </postal>
        <email>anders.rundgren.net@gmail.com</email>
        <uri>https://www.linkedin.com/in/andersrundgren/</uri>
      </address>
    </author>

    <date year="2019" />

    <area>Security</area>

    <workgroup></workgroup>

    <keyword>
      HTTP, REST, JSON, Canonicalization, Signatures
    </keyword>

    <abstract>
      <t>
        This specification describes how JCS <xref target="JCS"/>
        combined with JWS <xref target="RFC7515"/>,
        can be utilized to support HTTP <xref target="RFC7231"/> based applications
        needing digitally signed requests.
        The described scheme is tailored for Web applications
        using JSON <xref target="RFC8259"/> as message format.
        In addition, there is a specific variant for HTTP requests that do not have a message body like "GET".
        Targeted Web applications also include such utilizing the REST <xref target="REST"/> concept.
      </t>
      <t>
        The intended audiences of this document are Web tool vendors, as
        well as designers of secure Web applications.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
      <t>
        Currently there is no standard for digitally signing HTTP <xref target="RFC7231"/>
        requests.  This has lead to the development of several proprietary solutions (see <xref target="other.solutions"/>)
        typically building on using HTTP header data for holding security constructs,
        while JSON request data is provided in clear in the HTTP body.
      </t>
      <t>
        This specification is intended to provide a standardized alternative that
        also fully honors the REST concept without (directly) using HTTP headers for holding
        security constructs.  That is, JSON message data is supposed to also hold
        the security portion of a message.  This arrangement has the following characteristics:
        <list style="symbols">
          <t>
            Since REST requests (as a minimum) also are defined by the HTTP URI and HTTP Verb
            these attributes are added as reserved JSON properties to the signed request data.
          </t>
          <t>
            Due to the fact that messages compliant with this specification constitute of self-contained JSON objects,
            they may be serialized in databases or be embedded in other JSON objects.  The latter includes
            supporting counter signatures.
          </t>
          <t>
            The use of canonicalization provided by JCS makes signatures remain valid
            also after being processed by arbitrary JSON compliant tools.
          </t>
          <t>
            JWS is used in detached mode without modifications or extensions. 
          </t>
          <t>
            For general interoperability concerns as well as due to the relyiance on JCS,
            JSON message data is limitied to the I&nbhy;JSON <xref target="RFC7493"/> subset. 
          </t>
        </list>
        The above applies to HTTP requests using the methods "POST", "PUT" or "PATCH" described in <xref target="req.operation.withbody"/>.
      </t>
      <t>
        For HTTP requests using the methods "GET" or "DELETE", another entirely URI <xref target="RFC3986"/> based
        scheme is described in <xref target="req.operation.urionly"/>.
      </t>
    </section>

    <section anchor="Terminology" title="Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>

    <section anchor="req.operation.withbody" title="POST, PUT and PATCH Requests">
      <t>
        Assume you have an unsigned HTTP request like the following:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/json
  Content-Length: 1234

  {
    "something": "data",

         Additional application specific properties

  }]]></artwork></figure>
      </t>
      <t>
        Adding a signature to this request would require the following enhancements to the JSON payload:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  {
    "@req.uri": "https://example.com/transact/pay",
    "@req.verb": "POST",
    "something": "data",

         Additional application specific properties

    "@req.jws": "eyJhbGciOiJIUzI1NiJ9..VHVItCBCb849imarDtjw4"
  }]]></artwork></figure>
      </t>
      <t>
        Notes:
        <list style="symbols">
          <t>
            The argument to "@req.jws" (a detached JWS) was truncated for brevity.
          </t>
          <t>
            This specification presumes that JSON data ("payload") is expressed
            through a top level JSON Object.
          </t>
          <t>
            The "@req.verb" property is actually redundant since the HTTP method "POST" is default.
          </t>
        </list>
      </t>
      <t>
        The following subsections detail the operation for requests having an HTTP body.
      </t>
      <section anchor="req.creation.withbody" title="Request Creation">
        <t>
          For compliance with this specification the following properties MUST be
          be added to the JSON Object to be signed (unless they are optional
          in the specific request scenario):
        </t>
        <t>
          <list style="hanging">
            <t hangText="@req.uri">&nbsp;
              <vspace blankLines="0"/>
              REQUIRED property holding the complete target URI.
            </t>
            <t hangText="@req.verb">&nbsp;
              <vspace blankLines="0"/>
              OPTIONAL property holding the HTTP method in uppercase.
              If this property is missing, the HTTP method "POST" is assumed.
            </t>
            <t hangText="@req.headers">&nbsp;
              <vspace blankLines="0"/>
              OPTIONAL property holding a JSON object with HTTP headers
              related to the message.
              For more information see <xref target="signed.headers"/>.
            </t>
            <t hangText="@req.jws">&nbsp;
              <vspace blankLines="0"/>
              REQUIRED property holding a detached JWS signature calculated over the rest of the JSON payload
              using the method described in <xref target="JWSJCS"/>.
              Note that this property MUST be created and added after all other properties have
              been inserted in the JSON Object.
            </t>
          </list>
          Since these property names are reserved they MUST NOT be used for other purposes
          in applications whishing to use this specification.
        </t>
      </section>
      <section anchor="req.validation.withbody" title="Request Validation">
        <t>
          In addition to normal validation of received data, the following steps MUST also be performed:
          <list style="symbols">
            <t>
              The arguments to "@req.uri" and "@req.verb" MUST be verified for correctness
              which usually only can be done by the service processing the request.
              If there is a mismatch the service MUST reject the request with an
              HTTP code 400 (malformed request).
            </t>
            <t>
              The processing of the optional "@req.headers" element is described in <xref target="signed.headers"/>.
            </t>
            <t>
              The signature provided in "@req.jws" MUST be validated as described in <xref target="JWSJCS"/>.
            </t>
          </list>
        </t>
      </section>
    </section>
    <section anchor="req.operation.urionly" title="GET and DELETE Requests">
      <t>
        Assume you have an unsigned HTTP request like the following:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  GET /lookup?id=435 HTTP/1.1
  Host: example.com]]></artwork></figure>
      </t>
      <t>
        Adding a signature to this request would require the following enhancements to the URI:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  GET /lookup?id=435&@req.jws=eyJhiJ..VHVIt HTTP/1.1
  Host: example.com]]></artwork></figure>
      </t>
      <t>
        Notes:
        <list style="symbols">
          <t>
            The URI
            <vspace blankLines="0"/>
            "https://example.com/lookup?id=435&amp;@req.jws=eyJhiJ..VHVIt"
            <vspace blankLines="0"/>
            represents a complete serializable signed request object.
          </t>
          <t>
            The argument to "@req.jws" (a detached JWS) was truncated for brevity.
          </t>
        </list>
      </t>
      <t>
        The following subsections detail the operation for requests using an HTTP query string
        component for holding a signature.
      </t>
      <section anchor="req.creation.urionly" title="Request Creation">
        <t>
          In order to create a valid request, the steps described in this section
          MUST be adheared to.
        </t>
        <t>
          The data to be signed consists of the HTTP method in uppercase and the
          target URI separated by a comma character.  Applied to the sample that
          would yield the following string:
        </t>
        <t>
          <figure align="center"><artwork><![CDATA[  GET,https://example.com/lookup?id=435]]></artwork></figure>
        </t>
        <t>
          The resulting string is subsequently converted to UTF-8 <xref target="UNICODE"/> which
          applied to the sample would yield the following bytes, here in hexadecimal notation:
        </t>
        <t>
          <figure align="center"><artwork><![CDATA[  47 45 54 2c 68 74 74 70 73 3a 2f 2f 65 78 61 6d 70 6c 65 2e 63 6f
  6d 2f 6c 6f 6f 6b 75 70 3f 69 64 3d 34 33 35]]></artwork></figure>
        </t>
        <t>
          This data is used as "JWS Payload" to create a detached JWS object as described in
          Appendix F of <xref target="RFC7515"/>. Note that
          if additional HTTP headers need signing the following steps MUST be performed before the signature
          is generated:
          <list style="numbers">
            <t>
              Create a JSON header object as described in <xref target="signed.headers"/>.
            </t>
            <t>
              Add the JSON header object to the "JWS Header" object as follows:
              <list style="empty">
                <t>
                  "crit": ["@req.headers"],
                  <vspace blankLines="0"/>
                  "@req.headers": { the-JSON-header-object }
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>
          The resulting JWS string is supplied as an argument to an added query string "@req.jws" component.
          This component SHOULD be appended to the original unsiged request URI prepended by
          &amp; or ? depending on if it is the only query component or not.
        </t>
        <t>
          <list style="hanging">
            <t hangText="@req.headers">&nbsp;
              <vspace blankLines="0"/>
              OPTIONAL property holding a JSON object with HTTP headers
              related to the message.
              For more information see <xref target="signed.headers"/>.
            </t>
            <t hangText="@req.jws">&nbsp;
              <vspace blankLines="0"/>
              REQUIRED property holding a detached JWS signature calculated over the rest of the JSON payload
              using the method described in <xref target="JWSJCS"/>.
              Note that this property MUST be created and added after all other properties have
              been inserted in the JSON Object.
            </t>
          </list>
          Since these property names are reserved they MUST NOT be used for other purposes
          in applications whishing to use this specification.
        </t>
      </section>
      <section anchor="req.validation.urionly" title="Request Validation">
        <t>
          In addition to normal validation of received data, the following steps MUST also be performed:
          <list style="symbols">
            <t>
              The arguments to "@req.uri" and "@req.verb" MUST be checked for correctness
              which usually only can be done by the service processing the request.
              If there is a mismatch the service MUST reject the request with an
              HTTP code 400 (malformed request).
            </t>
            <t>
              The processing of the optional "@req.headers" element is described in <xref target="signed.headers"/>.
            </t>
            <t>
              The signature provided in "@req.jws" MUST be validated as described in <xref target="JWSJCS"/>.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>
        This document has no IANA actions.
      </t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
        Systems implementing this application note are subject
        to the same security considerations as JCS and JWS.
      </t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        TBD.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.3986'?>
      <?rfc include='reference.RFC.8259'?>
      <?rfc include='reference.RFC.7515'?>
      <?rfc include='reference.RFC.8174'?>
      <?rfc include='reference.RFC.7493'?>
      <?rfc include='reference.RFC.7231'?>
      <reference anchor="UNICODE" target="https://www.unicode.org/versions/Unicode10.0.0/">
        <front>
          <title>The Unicode Standard, Version 10.0.0</title>
          <author>
            <organization>The Unicode Consortium</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="JCS" target="https://tools.ietf.org/html/draft-rundgren-json-canonicalization-scheme-05">
        <front>
          <title>JSON Canonicalization Scheme - Work in progress</title>
          <author>
            <organization>A. Rundgren, B. Jordan, S. Erdtman</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="JWSJCS" target="https://tools.ietf.org/html/draft-rundgren-jws-jcs-signature-scheme-00">
        <front>
          <title>Combined JWS and JCS Signature Scheme - Work in progress</title>
          <author>
            <organization>A. Rundgren</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <references title="Informal References">
      <?rfc include='reference.RFC.4648'?>
      <reference anchor="REST" target="http://roy.gbiv.com/pubs/dissertation/top.htm">
        <front>
          <title>Architectural Styles and the Design of Network-based Software Architectures</title>
          <author>
            <organization>Roy Fielding</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="HTTPSIG" target="https://tools.ietf.org/html/draft-cavage-http-signatures-10">
        <front>
          <title>Signing HTTP Messages</title>
          <author>
            <organization>M. Cavage, M. Sporny</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="OBIE" target="https://www.openbanking.org.uk/">
        <front>
          <title>Open Banking API</title>
          <author>
            <organization>Open Banking UK</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="AWS" target="https://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html">
        <front>
          <title>Signing AWS API Requests</title>
          <author>
            <organization>Amazon.com</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="FAPI" target="https://openid.net/wg/fapi/">
        <front>
          <title>Financial-grade API</title>
          <author>
            <organization>Open ID</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="STET" target="https://www.stet.eu/en/psd2/">
        <front>
          <title>PSD2 API V1.4.1</title>
          <author>
            <organization>STET</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>

    <section anchor="signed.headers" title="Optional Headers">
      <t>
        Systems implementing this application note are subject
        to the same security considerations as JCS and JWS.
      </t>
    </section>
    <section anchor="other.solutions" title="Other Signed REST Solutions">
      <t>
        This appendix briefly outlines a few other solutions addressing
        Signed HTTP Requests.
      </t>
      <section anchor="other.aws" title="Amazon Web Services">
        <t>
          Amazon Web Sevices provides a system for their clients using
          HTTP headers holding security constructs while the
          digested HTTP body may hold any valid media type.
          For more information see the <xref target="AWS"/>.
          Signatures may also be added to query strings in a similar
          fashion to <xref target="req.operation.urionly"/>.
        </t>
      </section>
      <section anchor="other.httsignatures" title="HTTP Signatures">
        <t>
          HTTP Signatures <xref target="HTTPSIG"/> is a system using
          HTTP headers holding security constructs while the (optional)
          digested HTTP body may hold any valid media type.  This scheme
          has been adopted by the French Open Banking API <xref target="STET"/>.
          For more information see the Internet draft.
        </t>
      </section>
      <section anchor="other.openbanking" title="Open Banking (UK)">
        <t>
          The current (3.1) version of the Open Banking API <xref target="OBIE"/>
          use a scheme where a dedicated HTTP header holds
          a detached JWS signature covering a clear text JSON
          message in the HTTP body:
          <figure align="center"><artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/json
  x-jws-signature: eyJhbGciOiJSUzI1N..SD7xMbpL-2QgwUsAlMGzw
  Content-Length: 2765

  {
     "something": "data",
 
         Additional application specific properties

  }]]></artwork></figure>
        </t>
        <t>
          Notes:
          <list style="symbols">
            <t>
              The HTTP URI, method and headers are unsigned.
            </t>
            <t>
              The signature argument (a JWS) was truncated for brevity.
            </t>
          </list>
        </t>
      </section>
      <section anchor="other.fapi" title="Financial API">
        <t>
          The current version (Draft 06) of the financial API <xref target="FAPI"/> use
          a scheme where the payload is signed using JWS in Base64Url <xref target="RFC4648"/> mode:
          <figure align="center"><artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/jws
  Content-Length: 1288

  eyJhbGcRjIn0.ew0KICJfds56gty5ypc3MiOiA.2QgwUsA565656lMGzw]]></artwork></figure>
        </t>
        <t>
          Notes:
          <list style="symbols">
            <t>
              The HTTP URI, method and headers are unsigned.
            </t>
            <t>
              The JWS signature was truncated for brevity.
            </t>
          </list>
        </t>
        <t>
          <vspace blankLines="3"/>
        </t>
      </section>
    </section>
  </back>
</rfc>
