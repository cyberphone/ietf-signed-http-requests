<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" docName="draft-rundgren-signed-http-requests-00" ipr="trust200902">
  <front>
    <title abbrev="draft-rundgren-signed-http-requests">
      Signed HTTP Requests (SHREQ)
    </title>

    <author fullname="Anders Rundgren" initials="A." surname="Rundgren">
      <organization>Independent</organization>
      <address>
        <postal>
          <street></street>
          <code></code>
          <city>Montpellier</city>
          <country>France</country>
        </postal>
        <email>anders.rundgren.net@gmail.com</email>
        <uri>https://www.linkedin.com/in/andersrundgren/</uri>
      </address>
    </author>

    <date year="2019" />

    <area>Security</area>

    <workgroup></workgroup>

    <keyword>
      HTTP, REST, JSON, Canonicalization, Signatures
    </keyword>

    <abstract>
      <t>
        The SHREQ specification describes how JWS <xref target="RFC7515"/>
        combined with JCS <xref target="JCS"/>,
        can be utilized to support HTTP <xref target="RFC7231"/> based applications
        needing digitally signed requests.
        SHREQ is specifically tailored for Web applications using JSON <xref target="RFC8259"/> as
        data interchange format.
        However, there is also a SHREQ scheme for HTTP requests that do not have a message body like "GET".
        SHREQ was designed to be agnostic with respect to
        REST <xref target="REST"/> concepts versus traditional GET/POST schemes.
      </t>
      <t>
        The intended audiences of this document are Web tool vendors, as
        well as designers of secure Web applications.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
      <t>
        Currently there is no standard for digitally signing HTTP <xref target="RFC7231"/>
        requests.  This has lead to the development of a multitude
        of more or less proprietary solutions (see <xref target="other.solutions"/>),
        typically building on using HTTP header data for holding security constructs,
        while JSON request data is provided in clear in the HTTP body.
      </t>
      <t>
        SHREQ is intended to provide a standardized alternative that also fully
        honors the REST <xref target="REST"/> concept without using HTTP headers for holding
        security constructs.
        That is, JSON <xref target="RFC8259"/> formatted request data is supposed to
        also contain the security portion of a request.
        This arrangement has the following characteristics:
        <list style="symbols">
          <t>
            Since HTTP requests (as a minimum) also are defined by the HTTP URI and HTTP Method (verb),
            these attributes are added as reserved JSON properties to the signed request data.
          </t>
          <t>
            Due to the fact that messages compliant with this specification constitute
            of self-contained JSON objects, they may be serialized in databases or be
            embedded in other JSON objects.
            The latter includes supporting counter signatures.
          </t>
          <t>
            The use of canonicalization provided by JCS make signatures remain valid
            also after being processed by arbitrary JSON compliant tools.
          </t>
          <t>
            For general interoperability concerns as well as due to the reliance on JCS,
            JSON request data is limited to the I&nbhy;JSON <xref target="RFC7493"/> subset.
          </t>
        </list>
        The above applies to HTTP requests using the methods
        "POST", "PUT" or "PATCH" described in <xref target="req.operation.withbody"/>.
      </t>
      <t>
        For HTTP requests using the methods "GET" or "DELETE" there is another,
        entirely URI <xref target="RFC3986"/> based scheme described in <xref target="req.operation.urionly"/>.
      </t>
      <t>
        Both variants utilize JWS <xref target="RFC7515"/> in detached mode for holding the signature data.
      </t>
    </section>

    <section anchor="Terminology" title="Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>

    <section anchor="req.operation.withbody" title="POST, PUT and PATCH Requests">
      <t>
        Assume you have an unsigned HTTP request like the following:
      </t>
      <t>
        <figure align="center">
          <artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/json
  Content-Length: 1234

  {
    "something": "data",

         Additional application specific properties

  }]]></artwork>
        </figure>
      </t>
      <t>
        Adding a signature to this request would require the following enhancements to the JSON payload:
      </t>
      <t>
        <figure align="center">
          <artwork><![CDATA[  {
    "$req.uri": "https://example.com/transact/pay",
    "$req.mtd": "POST",
    "something": "data",

         Additional application specific properties

    "$req.jws": "eyJhbGciOiJIUzI1NiJ9..VHVItCBCb849imarDtjw4"
  }]]></artwork>
        </figure>
      </t>
      <t>
        Notes:
        <list style="symbols">
          <t>
            The argument to "$req.jws" (a detached JWS) was truncated for brevity.
          </t>
          <t>
            This specification presumes that request data is expressed as a JSON Object.
          </t>
          <t>
            The "$req.mtd" property is actually redundant since the HTTP method "POST" is default.
          </t>
        </list>
      </t>
      <t>
        The following subsections detail the operation for requests having an HTTP body.
      </t>
      <section anchor="req.creation.withbody" title="Request Creation">
        <t>
          Precondition: the application data to be submitted with the request already exists in
          a format serializable as a JSON Object, from now on referred to as "Message".
        </t>
        <t>
          In order to create a valid signed request, the steps (and ordering)
          described in this section MUST be adheared to:
          <list style="numbers">
            <t>
              Add a property "$req.uri" to "Message".  The argument to the
              property is a JSON String holding the full target URI.
            </t>
            <t>
              Add a property "$req.mtd" to "Message".  The argument to the
              property is a JSON String holding the HTTP method in uppercase.
              <vspace blankLines="1"/>
              Note: if the HTTP method is "POST" this step is optional because "POST" is default.
            </t>
            <t>
              If there is a need to include additional HTTP headers in the signed request data,
              perform the following steps:
              <list style="empty">
                <t>
                  Create a header object as described in <xref target="header.creation"/>.
                </t>
                <t>
                  Add a property "$req.hdr" to "Message".  The argument to the
                  property is the JSON Object created in the preceding step.
                </t>
              </list>
            </t>
            <t>
              Create a "JWS&nbsp;Payload" <xref target="RFC7515"/> as described in <xref target="canonicalization"/>.
            </t>
            <t>
              Create a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/> as described in <xref target="create.jwsprotheader"/>.
            </t>
            <t>
              Create a JWS string object as described in <xref target="create.signature"/>.
            </t>
            <t>
              Add a property "$req.jws" to "Message".  The argument to the
              property is a JSON String holding the result of the preceding step.
            </t>
            <t>
              Submit an HTTP <xref target="RFC7231"/> compliant request to the target URI including the following information:
              <list style="empty">
                <t>
                  The selected HTTP method.
                </t>
                <t>
                  An HTTP Body containing a JSON-serialized "Message" object using UTF-8 encoding.
                </t>
                <t>
                  An HTTP Header "Content-Length" with the argument set to the length in bytes of the HTTP Body.
                </t>
                <t>
                  An HTTP Header "Content-Type" with the argument set to "application/json".
                </t>
                <t>
                  All HTTP headers (if any) specified in step 3.
                </t>
                <t>
                  Other HTTP headers (if any) needed by the application.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      <section anchor="req.validation.withbody" title="Request Validation">
        <t>
          In addition to normal validation of received data, the following steps MUST also be performed:
          <list style="numbers">
            <t>
              If the HTTP header "Content-Type" is missing of is not "application/json"
              the service MUST reject the request with an HTTP code 400 (Malformed request).
            </t>
            <t>
              The arguments to "$req.uri", "$req.mtd" and "$req.jws" MUST be verified for correctness
              which usually only can be done by the service processing the request.
              If there is a mismatch the service MUST reject the request with an
              HTTP code 400 (Malformed request).
            </t>
            <t>
              Extract the "JWS&nbsp;Protected&nbsp;Header" and "JWS&nbsp;Signature" from the JWS
              object recieved in "$req.jws".
            </t>
            <t>
              If the algorithm or key (optionally) specified in the "JWS&nbsp;Protected&nbsp;Header" do not match
              the service's expectations or requirements, reject the request with
              an HTTP code 401 (Unauthorized).
            </t>
            <t>
              Processing of the optional "$req.hdr" element is described in <xref target="header.creation"/>.
            </t>
            <t>
              Finally, apply the common signature validation steps used by SHREQ:
              <list style="symbols">
                <t>
                  Validate the signature as a standard compact mode JWS <xref target="RFC7515"/>,
                  by concatenating "JWS&nbsp;Protected&nbsp;Header", "JWS&nbsp;Payload" and "JWS&nbsp;Signature"
                  using "." as separator between the elements.
                </t>
                <t>
                  If the signature fails to validate, reject the request with
                  an HTTP 401 code (Unauthorized).
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="req.operation.urionly" title="GET and DELETE Requests">
      <t>
        Assume you have an unsigned HTTP request like the following:
      </t>
      <t>
        <figure align="center">
          <artwork><![CDATA[  GET /lookup?id=435 HTTP/1.1
  Host: example.com]]></artwork>
        </figure>
      </t>
      <t>
        Adding a signature to this request would require the following enhancements to the URI:
      </t>
      <t>
        <figure align="center">
          <artwork><![CDATA[  GET /lookup?id=435&$req.jws=eyJhiJ..VHVIt HTTP/1.1
  Host: example.com]]></artwork>
        </figure>
      </t>
      <t>
        Notes:
        <list style="symbols">
          <t>
            The full URI to the sample above is as follows:
            <list style="empty">
              <t>
                https://example.com/lookup?id=435&amp;$req.jws=eyJhiJ..VHVIt
              </t>
            </list>
            This represents a complete serializable signed request object.
          </t>
          <t>
            The argument to "$req.jws" (a detached JWS) was truncated for brevity.
          </t>
        </list>
      </t>
      <t>
        The following subsections detail the operation for requests using an HTTP query string
        component for holding a signature.
      </t>
      <section anchor="req.creation.urionly" title="Request Creation">
        <t>
          In order to create a valid request, the steps (and ordering)
          described in this section MUST be adheared to:
          <list style="numbers">
            <t>
              Create a "JWS&nbsp;Payload" as described in <xref target="signable.uri"/>
              using the target URI and HTTP method as input.
            </t>
            <t>
              Create a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/>
              with algorithm and key data adapted for the application.
            </t>
            <t>
              If HTTP headers also need to be signed the following steps are performed:
              <list style="symbols">
                <t>
                  Create a SHREQ header object as described in <xref target="header.creation"/>.
                </t>
                <t>
                  Add the following elements to the "JWS&nbsp;Protected&nbsp;Header" object:
                  <list style="empty">
                    <t>
                      "crit": ["$req.hdr"]
                    </t>
                    <t>
                      "$req.hdr": { ... }
                    </t>
                  </list>
                  "{ ... }" denotes the SHREQ header object.
                </t>
              </list>
            </t>
            <t>
              Create a JWS string object as described in <xref target="create.signature"/>.
            </t>
            <t>
              Create a query string component by concatenating "$req.jws=" with the JWS string created in the preceding step.
              This component is appended to the original unsigned request URI prepended by
              &amp; or ? depending on if it is the only query component or not.
            </t>
            <t>
              Submit an HTTP <xref target="RFC7231"/> compliant request to the target URI including the following information:
              <list style="empty">
                <t>
                  The selected HTTP method.
                </t>
                <t>
                  All HTTP headers (if any) specified in step 3.
                </t>
                <t>
                  Other HTTP headers (if any) needed by the application.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      <section anchor="req.validation.urionly" title="Request Validation">
        <t>
          In addition to normal validation of received data (which may be carried out
          before or after the steps outlined here),
          the following steps MUST be performed in order to validate a URI based HTTP request:
          <list style="numbers">
            <t>
              Recreate the full URI and HTTP method from the received request.
              Save these items as "TargetURI" and "TargetMethod" respectively.
            </t>
            <t>
              Extract the JWS string from the "$req.jws" element which MUST reside in the query string of "TargetURI".
              Then extract the "JWS&nbsp;Protected&nbsp;Header" and "JWS&nbsp;Signature" from the received JWS string.
              If the JWS string is missing or malformed the service MUST reject the request
              with an HTTP 400 code (Malformed request).
            </t>
            <t>
              Remove the "$req.jws" query string component (including the preceding &amp; or ? character)
              from "TargetURI".
            </t>
            <t>
              Decode the "JWS&nbsp;Protected&nbsp;Header" element and extract the optional "crit" and "$req.hdr"
              properties (see step 3 of <xref target="req.creation.urionly"/>).
              Processing of the optional "$req.hdr" property is described in <xref target="header.validation"/>.
            </t>
            <t>
              Create a "JWS&nbsp;Payload" as described in <xref target="signable.uri"/>
              using "TargetURI" and "TargetMethod" method as input.
            </t>
            <t>
              If the algorithm or key (optionally) specified in the "JWS&nbsp;Protected&nbsp;Header" do not match
              the service's expectations or requirements, reject the request with
              an HTTP 401 code (Unauthorized).
            </t>
            <t>
              Validate the signature as described in step 5 in <xref target="req.validation.withbody"/>.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="common.ops" title="Common Operations">
      <t>
        SHREQ is a modular system using shared procedures described
        in the following subsections.
      </t>
      <section anchor="signable.uri" title="Creation of Signable URI">
        <t>
          For URI based requests, the steps to create a signable URI are as follows:
          <list style="numbers">
            <t>
              The data to be signed consists of the HTTP method in uppercase and the
              target URI, separated by a comma character.  Applied to the sample in
              <xref target="req.operation.urionly"/> that would yield the following string:
              <list style="empty">
                <t>
                  GET,https://example.com/lookup?id=435
                </t>
              </list>
            </t>
            <t>
              The resulting string is subsequently converted to UTF-8 <xref target="UNICODE"/> which
              applied to the sample would yield the following byte array, here in hexadecimal notation:
              <list style="empty">
                <t>
                  47 45 54 2c 68 74 74 70 73 3a 2f 2f 65 78 61 6d 70 6c 65 2e 63 6f
                  6d 2f 6c 6f 6f 6b 75 70 3f 69 64 3d 34 33 35
                </t>
              </list>
            </t>
            <t>
              The resulting byte array is subsequently encoded in Base64Url <xref target="RFC4648"/>
              notation which applied to the sample would yield the following string:
              <list style="empty">
                <t>
                  R0VULGh0dHBzOi8vZXhhbXBsZS5jb20vbG9va3VwP2lkPTQzNQ
                </t>
              </list>
            </t>
          </list>
          The string generated in the final step is intended to be used as a "JWS&nbsp;Payload" <xref target="RFC7515"/>.
        </t>
      </section>
      <section anchor="header.creation" title="Creation of Optional Header Object">
        <t>
          Cool.
        </t>
      </section>
      <section anchor="header.validation" title="Validation of Optional Header Object">
        <t>
          Cool.
        </t>
      </section>
      <section anchor="create.signature" title="Creation of Detached JWS Object">
        <t>
          Use the "JWS Protected Header" and "JWS Payload" strings together
          with a for the purpose designated signature key
          to create a detached JWS object (a string) as described in
          Appendix F of [RFC7515].
        </t>
      </section>
      <section anchor="create.jwsprotheader" title="Creation of JWS Protected Header">
        <t>
          Create a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/>
          with algorithm and key data adapted for the application.
        </t>
      </section>
      <section anchor="validate.signature" title="Validation of JWS Object">
        <t>
          Create JWS compact object by concatenating the "JWS&nbsp;Protected Header",
          "JWS&nbsp;Payload" and "JWS&nbsp;Signature" strings, separated by point characters (".").
        </t>
      </section>
      <section anchor="canonicalization" title="Canonicalization of &quot;Message&quot;">
        <t>
          Cool.
        </t>
      </section>
    </section>

      <section anchor="IANA" title="IANA Considerations">
        <t>
          This document currently has no IANA actions but the reserved property names
          below could be candidates for IANA registration:
          <list style="hanging">
            <t hangText="$req.uri">
              &nbsp;
              <vspace blankLines="0"/>
              Property holding the target URI.
            </t>
            <t hangText="$req.mtd">
              &nbsp;
              <vspace blankLines="0"/>
              Property holding the HTTP method in uppercase.
            </t>
            <t hangText="$req.hdr">
              &nbsp;
              <vspace blankLines="0"/>
              Property holding a JSON object containing a list of HTTP headers and a consolidated hash of the headers and their the arguments.
            </t>
            <t hangText="$req.jws">
              &nbsp;
              <vspace blankLines="0"/>
              Property holding a detached JWS signature.
            </t>
          </list>
        </t>
      </section>

      <section anchor="Security" title="Security Considerations">
        <t>
          Systems implementing this application note are subject
          to the same security considerations as JCS and JWS.
        </t>
      </section>

      <section anchor="Acknowledgements" title="Acknowledgements">
        <t>
          TBD.
        </t>
      </section>
    </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.3986'?>
      <?rfc include='reference.RFC.4648'?>
      <?rfc include='reference.RFC.8259'?>
      <?rfc include='reference.RFC.7515'?>
      <?rfc include='reference.RFC.8174'?>
      <?rfc include='reference.RFC.7493'?>
      <?rfc include='reference.RFC.7231'?>
      <reference anchor="UNICODE" target="https://www.unicode.org/versions/Unicode10.0.0/">
        <front>
          <title>The Unicode Standard, Version 10.0.0</title>
          <author>
            <organization>The Unicode Consortium</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="JCS" target="https://tools.ietf.org/html/draft-rundgren-json-canonicalization-scheme-05">
        <front>
          <title>JSON Canonicalization Scheme - Work in progress</title>
          <author>
            <organization>A. Rundgren, B. Jordan, S. Erdtman</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="JWSJCS" target="https://tools.ietf.org/html/draft-rundgren-jws-jcs-signature-scheme-00">
        <front>
          <title>Combined JWS and JCS Signature Scheme - Work in progress</title>
          <author>
            <organization>A. Rundgren</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <references title="Informal References">
      <reference anchor="REST" target="http://roy.gbiv.com/pubs/dissertation/top.htm">
        <front>
          <title>Architectural Styles and the Design of Network-based Software Architectures</title>
          <author>
            <organization>Roy Fielding</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="HTTPSIG" target="https://tools.ietf.org/html/draft-cavage-http-signatures-10">
        <front>
          <title>Signing HTTP Messages</title>
          <author>
            <organization>M. Cavage, M. Sporny</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="OBIE" target="https://www.openbanking.org.uk/">
        <front>
          <title>Open Banking API</title>
          <author>
            <organization>Open Banking UK</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="AWS" target="https://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html">
        <front>
          <title>Signing AWS API Requests</title>
          <author>
            <organization>Amazon.com</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="FAPI" target="https://openid.net/wg/fapi/">
        <front>
          <title>Financial-grade API</title>
          <author>
            <organization>Open ID</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="STET" target="https://www.stet.eu/en/psd2/">
        <front>
          <title>PSD2 API V1.4.1</title>
          <author>
            <organization>STET</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <section anchor="other.solutions" title="Other Signed HTTP Request Solutions">
      <t>
        This appendix briefly outlines a few other solutions addressing
        Signed HTTP Requests.
      </t>
      <section anchor="other.aws" title="Amazon Web Services">
        <t>
          Amazon Web Sevices provides a system for their clients using
          HTTP headers holding security constructs while the
          digested HTTP body may hold any valid media type.
          For more information see the <xref target="AWS"/>.
          Signatures may also be added to query strings in a similar
          fashion to <xref target="req.operation.urionly"/>.
        </t>
      </section>
      <section anchor="other.httsignatures" title="HTTP Signatures">
        <t>
          HTTP Signatures is a system using
          HTTP headers holding security constructs while the (optional)
          digested HTTP body may hold any valid media type.
          This scheme has been adopted by the French Open Banking API <xref target="STET"/>.
          For more information see the Internet draft <xref target="HTTPSIG"/>.
          HTTP Signatures also supports signed response data.
        </t>
      </section>
      <section anchor="other.openbanking" title="Open Banking (UK)">
        <t>
          The current (3.1) version of the Open Banking API <xref target="OBIE"/>
          use a scheme where a dedicated HTTP header holds
          a detached JWS signature covering a clear text JSON
          message in the HTTP body:
          <figure align="center"><artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/json
  x-jws-signature: eyJhbGciOiJSUzI1N..SD7xMbpL-2QgwUsAlMGzw
  Content-Length: 2765

  {
     "something": "data",
 
         Additional application specific properties

  }]]></artwork></figure>
        </t>
        <t>
          Notes:
          <list style="symbols">
            <t>
              The HTTP URI, method and headers are unsigned.
            </t>
            <t>
              The signature argument (a JWS) was truncated for brevity.
            </t>
          </list>
        </t>
      </section>
      <section anchor="other.fapi" title="Financial API">
        <t>
          The current version (Draft 06) of the financial API <xref target="FAPI"/> use
          a scheme where the payload is signed using JWS in Base64Url <xref target="RFC4648"/> mode:
          <figure align="center"><artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/jws
  Content-Length: 1288

  eyJhbGcRjIn0.ew0KICJfds56gty5ypc3MiOiA.2QgwUsA565656lMGzw]]></artwork></figure>
        </t>
        <t>
          Notes:
          <list style="symbols">
            <t>
              The HTTP URI, method and headers are unsigned.
            </t>
            <t>
              The JWS signature was truncated for brevity.
            </t>
          </list>
        </t>
        <t>
          <vspace blankLines="3"/>
        </t>
      </section>
    </section>
  </back>
</rfc>
