<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" docName="draft-rundgren-signed-http-requests-00" ipr="trust200902">
  <front>
    <title abbrev="draft-rundgren-signed-http-requests">
      Signed HTTP Requests (SHREQ)
    </title>

    <author fullname="Anders Rundgren" initials="A." surname="Rundgren">
      <organization>Independent</organization>
      <address>
        <postal>
          <street></street>
          <code></code>
          <city>Montpellier</city>
          <country>France</country>
        </postal>
        <email>anders.rundgren.net@gmail.com</email>
        <uri>https://www.linkedin.com/in/andersrundgren/</uri>
      </address>
    </author>

    <date year="2019" />

    <area>Security</area>

    <workgroup></workgroup>

    <keyword>
      HTTP, REST, JSON, Canonicalization, Signatures
    </keyword>

    <abstract>
      <t>
        The SHREQ specification describes how JWS <xref target="RFC7515"/>
        combined with JCS <xref target="JCS"/>,
        can be utilized to support HTTP <xref target="RFC7231"/> based applications
        needing digitally signed requests.
        SHREQ is specifically tailored for Web applications using JSON <xref target="RFC8259"/> as
        data interchange format.
        However, there is also a SHREQ scheme for HTTP requests that do not have a message body like "GET".
        SHREQ was designed to be agnostic with respect to
        REST <xref target="REST"/> concepts versus traditional GET/POST schemes.
      </t>
      <t>
        The intended audiences of this document are Web tool vendors, as
        well as designers of secure Web applications.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
      <t>
        Currently there is no standard for digitally signing HTTP <xref target="RFC7231"/>
        requests.  This has lead to the development of a multitude
        of more or less proprietary solutions (see <xref target="other.solutions"/>),
        typically building on using HTTP header data for holding security constructs,
        while JSON request data is provided in clear in the HTTP body.
      </t>
      <t>
        SHREQ is intended to provide a standardized alternative, including supporting
        the REST <xref target="REST"/> concept.
      </t>
      <t>
        SHREQ builds on a common security model where the following elements of an HTTP request are signed:
        <list style="symbols">
          <t>
            HTTP URI <xref target="RFC3986"/>.
          </t>
          <t>
            HTTP method.
          </t>
          <t>
            HTTP body (if applicable for the specific HTTP method).
          </t>
          <t>
            Optional: Additional HTTP headers as defined by the actual ecosystem.
          </t>
        </list>
      </t>
      <t>
        One of the design goals was turning signed requests into self-contained objects.
        To achieve this for HTTP methods having a body (see <xref target="req.operation.withbody"/>),
        the JSON <xref target="RFC8259"/> formatted request data also carries the signature.
        This arrangement has certain implications:
        <list style="symbols">
          <t>
            Signed requests may be stored in databases or be embedded in other JSON objects.
            The latter includes supporting counter signatures.  The canonicalization
            offered by JCS enables validating the integrity of request data at any time.
          </t>
          <t>
            For general interoperability concerns as well as due to the reliance on JCS,
            JSON request data is limited to the I&nbhy;JSON <xref target="RFC7493"/> subset.
          </t>
        </list>
      </t>
      <t>
        For URI based HTTP methods (see <xref target="req.operation.urionly"/>), the
        signature is provided in the URI itself.
      </t>
      <t>
        Both variants utilize JWS <xref target="RFC7515"/> in detached mode for holding the signature data.
      </t>
      <t>
        For supporting signed HTTP responses any solution may be used.  For maximum "symmetry"
        and code reuse, the <xref target="JWSJCS"/> scheme should be a suitable candidate
        since it builds on the same building blocks as SHREQ.
      </t>
    </section>

    <section anchor="Terminology" title="Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>

    <section anchor="req.operation.withbody" title="POST, PUT and PATCH Requests">
      <t>
        Assume you have an unsigned HTTP request like the following:
      </t>
      <t>
        <figure align="center">
          <artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/json
  Content-Length: 1234

  {
    "something": "data",

         Additional application specific properties

  }]]></artwork>
        </figure>
      </t>
      <t>
        Adding a signature to the request above would require the following enhancements to the JSON payload:
      </t>
      <t>
        <figure align="center">
          <artwork><![CDATA[  {
    "$req.uri": "https://example.com/transact/pay",
    "$req.mtd": "POST",
    "something": "data",

         Additional application specific properties

    "$req.jws": "eyJhbGciOiJIUzI1NiJ9..VHVItCBCb849imarDtjw4"
  }]]></artwork>
        </figure>
      </t>
      <t>
        Notes:
        <list style="symbols">
          <t>
            The argument to "$req.jws" (a detached JWS) was truncated for brevity.
          </t>
          <t>
            This specification presumes that request data is expressed as a JSON Object.
          </t>
          <t>
            The "$req.mtd" property is actually redundant since the HTTP method "POST" is the default.
          </t>
          <t>
            The ordering of properties is insignificant.
          </t>
        </list>
      </t>
      <t>
        The following subsections detail the operation for requests having an HTTP body.
      </t>
      <section anchor="req.creation.withbody" title="Request Creation">
        <t>
          Precondition: the application data to be submitted with the request already exists in
          a format serializable as a JSON Object, from now on referred to as "Message".
        </t>
        <t>
          In order to create a valid signed request, the following steps (and ordering)
          MUST be adhered to:
          <list style="numbers">
            <t>
              Add a property "$req.uri" to "Message" where the argument
              is a JSON String holding the complete target URI.
            </t>
            <t>
              Add a property "$req.mtd" to "Message" where the argument
              is a JSON String holding the selected HTTP method in uppercase.
              <vspace blankLines="1"/>
              Note: for the HTTP method "POST", this step is optional because "POST" is the default.
            </t>
            <t>
              If there is a need to include additional HTTP headers in the signed request data,
              perform the following steps:
              <list style="symbols">
                <t>
                  Create a header object as described in <xref target="header.creation"/>.
                </t>
                <t>
                  Add a property "$req.hdr" to "Message" where the argument
                  is the JSON Object created in the preceding step.
                </t>
              </list>
            </t>
            <t>
              Create a "JWS&nbsp;Payload" <xref target="RFC7515"/> as described in <xref target="signable.json"/>.
            </t>
            <t>
              Create a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/> as described in <xref target="create.jwsprotheader"/>.
            </t>
            <t>
              Create a JWS string object as described in <xref target="create.signature"/>.
            </t>
            <t>
              Add a property "$req.jws" to "Message" where the argument
              is a JSON String holding the result of the preceding step.
            </t>
            <t>
              Serialize "Message" into an UTF-8 encoded byte array called "requestData".
            </t>
            <t>
              Submit an HTTP <xref target="RFC7231"/> compliant request to the target URI including the following information:
              <list style="symbols">
                <t>
                  Selected HTTP method.
                </t>
                <t>
                  HTTP Header "Content-Length" with the argument set to the length of "requestData".
                </t>
                <t>
                  HTTP Header "Content-Type" with the argument set to "application/json".
                </t>
                <t>
                  All HTTP headers (if any) specified in step 3.
                </t>
                <t>
                  Other HTTP headers (if any) needed by the application.
                </t>
                <t>
                  An HTTP Body containing "requestData".
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      <section anchor="req.validation.withbody" title="Request Validation">
        <t>
          In order to validate a request the following steps MUST be performed:
          <list style="numbers">
            <t>
              If the HTTP header "Content-Type" is missing or differs from "application/json"
              the service MUST reject the request with an HTTP 400 code (Malformed request).
            </t>
            <t>
              If the HTTP header "Content-Length" is missing or malformed
              the service MUST reject the request with an HTTP 400 code (Malformed request).
              Save the length data.
            </t>
            <t>
              Read HTTP body data into a byte array with the length retrieved in the preceding step.
            </t>
            <t>
              Parse the byte array created in the preceding step with a JSON parser and return the result
              in an object from now on referred to as "Message".
              If there are parsing errors the service MUST reject the request with an
              HTTP 400 code (Malformed request).
            </t>
            <t>
              Using "Message", the "$req.uri" property is read.
              If "$req.uri" is missing or does not match the anticipated value or is not a JSON String the service MUST reject the request with an
              HTTP 400 code (Malformed request).
            </t>
            <t>
              Using "Message", the "$req.mtd" property is read.
              if "$req.mtd" is missing the HTTP method is assumed to be "POST" else it is assumed to be the read value.
              If the computed method does not match the anticipated value is not a JSON String the service MUST reject the request with an
              HTTP 400 code (Malformed request).
            </t>
            <t>
              Using "Message", the "$req.jws" property is read.
              If "$req.jws" is missing or is not a JSON String the service MUST reject the request with an
              HTTP 400 code (Malformed request).
              Decode the read string as described in <xref target="jws.string.decoding"/>.
            </t>
            <t>
              If the optional "$req.hdr" property is present in "Message", extract the argument
              and process it as described in <xref target="validate.header"/>.
            </t>
            <t>
              Remove the "$req.jws" property from "Message".
            </t>
            <t>
              Create a "JWS&nbsp;Payload" <xref target="RFC7515"/> object as described in <xref target="signable.json"/>.
            </t>
            <t>
              Perform signature validation as described in <xref target="validate.signature"/>.
            </t>
          </list>
          Note: validation of application specific data can be performed anytime after step 4.
          The action(s) to perform after a possible failure is out of scope for this specification.
        </t>
      </section>
    </section>

    <section anchor="req.operation.urionly" title="GET and DELETE Requests">
      <t>
        Assume you have an unsigned HTTP request like the following:
      </t>
      <t>
        <figure align="center">
          <artwork><![CDATA[  GET /lookup?id=435 HTTP/1.1
  Host: example.com]]></artwork>
        </figure>
      </t>
      <t>
        Adding a signature to this request would require the following enhancements to the URI:
      </t>
      <t>
        <figure align="center">
          <artwork><![CDATA[  GET /lookup?id=435&$req.jws=eyJhiJ..VHVIt HTTP/1.1
  Host: example.com]]></artwork>
        </figure>
      </t>
      <t>
        Notes:
        <list style="symbols">
          <t>
            The full URI to the sample above is as follows:
            <list style="empty">
              <t>
                https://example.com/lookup?id=435&amp;$req.jws=eyJhiJ..VHVIt
              </t>
            </list>
            This represents a complete serializable signed request object.
          </t>
          <t>
            The argument to "$req.jws" (a detached JWS) was truncated for brevity.
          </t>
        </list>
      </t>
      <t>
        The following subsections detail the operation for requests using an HTTP query string
        component for holding a signature.
      </t>
      <section anchor="req.creation.urionly" title="Request Creation">
        <t>
          In order to create a valid request, the steps (and ordering)
          described in this section MUST be adhered to:
          <list style="numbers">
            <t>
              Create a "JWS&nbsp;Payload" as described in <xref target="signable.uri"/>
              using the target URI and HTTP method as input.
            </t>
            <t>
              Create a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/> as described in <xref target="create.jwsprotheader"/>.
            </t>
            <t>
              If HTTP headers also need to be signed the following steps are performed:
              <list style="symbols">
                <t>
                  Create an HTTP header object as described in <xref target="header.creation"/>.
                </t>
                <t>
                  Add the following elements to the "JWS&nbsp;Protected&nbsp;Header" object:
                  <list style="empty">
                    <t>
                      "crit": ["$req.hdr"]
                    </t>
                    <t>
                      "$req.hdr": { ... }
                    </t>
                  </list>
                  "{ ... }" denotes the HTTP header object.
                </t>
              </list>
            </t>
            <t>
              Create a JWS string object as described in <xref target="create.signature"/>.
            </t>
            <t>
              Create a query string component by concatenating "$req.jws=" with the JWS string created in the preceding step.
              This component is appended to the original unsigned request URI prepended by
              &amp; or ? depending on if it is the only query component or not.
            </t>
            <t>
              Submit an HTTP <xref target="RFC7231"/> compliant request to the target URI including the following information:
              <list style="symbols">
                <t>
                  Selected HTTP method.
                </t>
                <t>
                  All HTTP headers (if any) specified in step 3.
                </t>
                <t>
                  Other HTTP headers (if any) needed by the application.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      <section anchor="req.validation.urionly" title="Request Validation">
        <t>
          In addition to normal validation of received data (which may be carried out
          before or after the steps outlined here),
          the following steps MUST be performed in order to validate a URI based HTTP request:
          <list style="numbers">
            <t>
              Recreate the full URI and HTTP method from the received request.
              Save these items as "TargetURI" and "TargetMethod" respectively.
            </t>
            <t>
              Extract the JWS string from the "$req.jws" element which MUST reside in the query string of "TargetURI".
              If the JWS string is missing the service MUST reject the request
              with an HTTP 400 code (Malformed request).
              Decode the argument to "$req.jws" as described in <xref target="jws.string.decoding"/>.
            </t>
            <t>
              Remove the "$req.jws" query string component (including the preceding &amp; or ? character)
              from "TargetURI".
            </t>
            <t>
              if the "JWS&nbsp;Protected&nbsp;Header" object contains a "$req.hdr" property,
              perform the following steps:
              <list style="symbols">
                <t>
                  Verify that the "JWS&nbsp;Protected&nbsp;Header" object contains a JWS "crit"
                  property holding a JSON Array with JSON String elements where
                  one of the elements MUST be "$req.hdr".
                  If there is a mismatch the service MUST reject the request
                  with an HTTP 400 code (Malformed request).
                </t>
                <t>
                  Extract the argument to "$req.hdr" from the "JWS&nbsp;Protected&nbsp;Header" and process it as described in <xref target="validate.header"/>.
                </t>
              </list>
            </t>
            <t>
              Create a "JWS&nbsp;Payload" object as described in <xref target="signable.uri"/>
              using "TargetURI" and "TargetMethod" method as input.
            </t>
            <t>
              Perform signature validation as described in <xref target="validate.signature"/>.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="common.ops" title="Common Operations">
      <t>
        SHREQ is a modular system using shared procedures described
        in the following subsections.
      </t>
      <section anchor="signable.json" title="Creation of Signable JSON Data">
        <t>
          Unsigned request data is now supposed to reside in "Message".
          To facilitate resilience against (legitimate) variances in JSON processing
          between different platforms and systems,
          "Message" needs to be canonicalized and serialized into a UTF-8 encoded byte array.
          If the used JSON tools offer intrinsic support for JCS <xref target="JCS"/>, this is
          typically a single operation, else the followings steps are performed:
          <list style="numbers">
            <t>
              Serialize "Message" using standard JSON tools for the platform.
            </t>
            <t>
              Create a canonical and UTF-8 encoded form of the data created in the preceding step,
              through an external software solution supporting JCS.
            </t>
          </list>
          The output from JCS is intended to be used as a "JWS&nbsp;Payload" <xref target="RFC7515"/> object.
        </t>
      </section>
      <section anchor="signable.uri" title="Creation of Signable URI Data">
        <t>
          For URI based requests, the steps to create signable URI data are as follows:
          <list style="numbers">
            <t>
              The signable URI data consists of the selected HTTP method in uppercase and the
              target URI, separated by a comma character.  Applied to the sample in
              <xref target="req.operation.urionly"/> that would yield the following string:
              <list style="empty">
                <t>
                  GET,https://example.com/lookup?id=435
                </t>
              </list>
            </t>
            <t>
              The resulting string is subsequently converted to UTF-8 <xref target="UNICODE"/> which
              applied to the sample would yield the following byte array, here displayed
              in hexadecimal notation:
              <list style="empty">
                <t>
                  47 45 54 2c 68 74 74 70 73 3a 2f 2f 65 78 61 6d 70 6c 65 2e 63 6f
                  6d 2f 6c 6f 6f 6b 75 70 3f 69 64 3d 34 33 35
                </t>
              </list>
            </t>
          </list>
          The output from the last step is assigned to a "JWS&nbsp;Payload" <xref target="RFC7515"/> object.
        </t>
      </section>
      <section anchor="header.creation" title="Creation of HTTP Header Object">
        <t>
          Cool.
        </t>
      </section>
      <section anchor="create.jwsprotheader" title="Creation of JWS Protected Header">
        <t>
          Create a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/>
          JSON object with algorithm and key data adapted for the application.
        </t>
      </section>
      <section anchor="create.signature" title="Creation of JWS String">
        <t>
          To create a detached JWS object (see Appendix F of <xref target="RFC7515"/>),
          perform the following steps:
          <list style="numbers">
            <t>
              Serialize the previously defined "JWS Protected Header" object into a UTF-8 encoded byte array.
            </t>
            <t>
              Base64Url-encode the output from the preceding step into a local variable "jwsProtectedHeaderB64U".
            </t>
            <t>
              Set local variable "signedData" to the UTF-8 encoded representation of the
              concatenation of:
              <list style="empty">
                <t>
                  The previously defined variable "jwsProtectedHeaderB64U".
                </t>
                <t>
                  A point character (".").
                </t>
                <t>
                  The previously defined variable "JWS&nbsp;Payload",
                  here encoded in Base64Url <xref target="RFC4648"/>.
                </t>
              </list>
            </t>
            <t>
              Use the designated signature key, signature algorithm and
              "signedData" to create a "JWS&nbsp;Signature" object (byte array).
            </t>
            <t>
              Return the string consisting of the concatenation of:
              <list style="empty">
                <t>
                  The previously defined variable "jwsProtectedHeaderB64U".
                </t>
                <t>
                  Two point characters ("..").
                </t>
                <t>
                  The previously defined variable "JWS&nbsp;Signature",
                  here encoded in Base64Url <xref target="RFC4648"/>.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      <section anchor="jws.string.decoding" title="Decoding of JWS String">
        <t>
          The following processing steps presume that there is an input string holding
          a detached JWS compact object, here called "jwsString":
          <list style="numbers">
            <t>
              Verify that "jwsString" has the syntax "header..signature".
            </t>
            <t>
              Assign the "header" portion of "jwsString" to a variable "jwsProtectedHeaderB64U".
            </t>
            <t>
              Base64Url-decode "jwsProtectedHeaderB64U" into a byte array.
            </t>
            <t>
              Parse the output from the preceding step with a JSON parser and
              assume that the result is a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/> object.
            </t>
            <t>
              Base64Url-decode the "signature" portion of "jwsString" into a byte array.
            </t>
            <t>
              Use the output from the preceding step to create a "JWS&nbsp;Signature" <xref target="RFC7515"/> object.
            </t>
          </list>
          If any of the steps fails, the service MUST reject the request with an HTTP 400 code (Malformed request). 
        </t>
      </section>
      <section anchor="validate.signature" title="Validation of JWS Object">
        <t>
          Validation of the detached JWS object (see Appendix F of <xref target="RFC7515"/>),
          using the previously extracted and decoded objects requires the following steps:
          <list style="numbers">
            <t>
              Verify that the received "JWS&nbsp;Protected&nbsp;Header" contains
              a JWS algorithm ("alg") and key identifiers that
              matches the needs of the application.
            </t>
            <t>
              Retrieve the signature validation key. This part is application specific since
              the key may be implicit, specified by a key ID ("kid") or be supplied
              in a certificate path ("x5c").
            </t>
            <t>
              Set a local variable "signedData" to the UTF-8 encoded representation of the
              concatenation of:
              <list style="empty">
                <t>
                  The previously defined variable "jwsProtectedHeaderB64U".
                </t>
                <t>
                  A point character (".").
                </t>
                <t>
                  The previously defined variable "JWS Payload",
                  here encoded in Base64Url <xref target="RFC4648"/>.
                </t>
              </list>
            </t>
            <t>
              Validate the signature using the algorithm retrieved in step 1,
              the signature validation key from step 2,
              "signedData" from step 3 and the previously collected "JWS&nbsp;Signature" object (byte array). 
            </t>
          </list>
          If any of these steps fail, the service MUST reject the request with an
          HTTP 401 code (Unauthorized). 
        </t>
      </section>
      <section anchor="validate.header" title="Validation of HTTP Header Object">
        <t>
          Cool.
        </t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>
        This document currently has no IANA actions but the reserved property names
        below could be candidates for IANA registration:
        <list style="hanging">
          <t hangText="$req.uri">
            &nbsp;
            <vspace blankLines="0"/>
            Property holding the target URI.
          </t>
          <t hangText="$req.mtd">
            &nbsp;
            <vspace blankLines="0"/>
            Property holding the HTTP method in uppercase.
          </t>
          <t hangText="$req.hdr">
            &nbsp;
            <vspace blankLines="0"/>
            Property holding a JSON object containing a list of HTTP headers and a consolidated hash of the headers and their the arguments.
          </t>
          <t hangText="$req.jws">
            &nbsp;
            <vspace blankLines="0"/>
            Property holding a detached JWS signature.
          </t>
        </list>
      </t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
        Systems implementing this application note are subject
        to the same security considerations as JCS and JWS.
      </t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        TBD.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.3986'?>
      <?rfc include='reference.RFC.4648'?>
      <?rfc include='reference.RFC.8259'?>
      <?rfc include='reference.RFC.7515'?>
      <?rfc include='reference.RFC.8174'?>
      <?rfc include='reference.RFC.7493'?>
      <?rfc include='reference.RFC.7231'?>
      <reference anchor="UNICODE" target="https://www.unicode.org/versions/Unicode10.0.0/">
        <front>
          <title>The Unicode Standard, Version 10.0.0</title>
          <author>
            <organization>The Unicode Consortium</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="JCS" target="https://tools.ietf.org/html/draft-rundgren-json-canonicalization-scheme-05">
        <front>
          <title>JSON Canonicalization Scheme - Work in progress</title>
          <author>
            <organization>A. Rundgren, B. Jordan, S. Erdtman</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="JWSJCS" target="https://github.com/cyberphone/jws-jcs">
        <front>
          <title>Combined JWS and JCS Signature Scheme - Work in progress</title>
          <author>
            <organization>A. Rundgren</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <references title="Informal References">
      <reference anchor="REST" target="http://roy.gbiv.com/pubs/dissertation/top.htm">
        <front>
          <title>Architectural Styles and the Design of Network-based Software Architectures</title>
          <author>
            <organization>Roy Fielding</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="HTTPSIG" target="https://tools.ietf.org/html/draft-cavage-http-signatures-10">
        <front>
          <title>Signing HTTP Messages</title>
          <author>
            <organization>M. Cavage, M. Sporny</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="OBIE" target="https://www.openbanking.org.uk/">
        <front>
          <title>Open Banking API</title>
          <author>
            <organization>Open Banking UK</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="AWS" target="https://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html">
        <front>
          <title>Signing AWS API Requests</title>
          <author>
            <organization>Amazon.com</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="FAPI" target="https://openid.net/wg/fapi/">
        <front>
          <title>Financial-grade API</title>
          <author>
            <organization>Open ID</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="STET" target="https://www.stet.eu/en/psd2/">
        <front>
          <title>PSD2 API V1.4.1</title>
          <author>
            <organization>STET</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>

    <section anchor="other.solutions" title="Other Signed HTTP Request Solutions">
      <t>
        This appendix briefly outlines a few other solutions addressing
        Signed HTTP Requests.
      </t>
      <section anchor="other.aws" title="Amazon Web Services">
        <t>
          Amazon Web Sevices provides a system for their clients using
          HTTP headers holding security constructs while the
          digested HTTP body may hold any valid media type.
          For more information see the <xref target="AWS"/>.
          Signatures may also be added to query strings in a similar
          fashion to <xref target="req.operation.urionly"/>.
        </t>
      </section>
      <section anchor="other.httsignatures" title="HTTP Signatures">
        <t>
          HTTP Signatures is a system using
          HTTP headers holding security constructs while the (optional)
          digested HTTP body may hold any valid media type.
          This scheme has been adopted by the French Open Banking API <xref target="STET"/>.
          For more information see the Internet draft <xref target="HTTPSIG"/>.
          HTTP Signatures also supports signed response data.
        </t>
      </section>
      <section anchor="other.openbanking" title="Open Banking (UK)">
        <t>
          The current (3.1) version of the Open Banking API <xref target="OBIE"/>
          use a scheme where a dedicated HTTP header holds
          a detached JWS signature covering a clear text JSON
          message in the HTTP body:
          <figure align="center"><artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/json
  x-jws-signature: eyJhbGciOiJSUzI1N..SD7xMbpL-2QgwUsAlMGzw
  Content-Length: 2765

  {
     "something": "data",
 
         Additional application specific properties

  }]]></artwork></figure>
        </t>
        <t>
          Notes:
          <list style="symbols">
            <t>
              The HTTP URI, method and headers are unsigned.
            </t>
            <t>
              The signature argument (a JWS) was truncated for brevity.
            </t>
          </list>
        </t>
      </section>
      <section anchor="other.fapi" title="Financial API">
        <t>
          The current version (Draft 06) of the financial API <xref target="FAPI"/> use
          a scheme where the payload is signed using JWS in Base64Url <xref target="RFC4648"/> mode:
          <figure align="center"><artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/jws
  Content-Length: 1288

  eyJhbGcRjIn0.ew0KICJfds56gty5ypc3MiOiA.2QgwUsA565656lMGzw]]></artwork></figure>
        </t>
        <t>
          Notes:
          <list style="symbols">
            <t>
              The HTTP URI, method and headers are unsigned.
            </t>
            <t>
              The JWS signature was truncated for brevity.
            </t>
          </list>
        </t>
      </section>
    </section>
  
    <section anchor="shreq.development" title="Development Portal">
      <t>
        The SHREQ specification is currently developed at:
        <eref target="https://github.com/cyberphone/ietf-signed-http-requests">https://github.com/cyberphone/ietf-signed-http-requests</eref>.
      </t>
      <t>
        SHREQ source code and test data is available at:
        <eref target="https://github.com/cyberphone/shreq">https://github.com/cyberphone/shreq</eref>
      </t>
      <t>
        <vspace blankLines="3"/>
      </t>
    </section>
  
  </back>
</rfc>
