<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" docName="draft-rundgren-signed-http-requests-00" ipr="trust200902">
  <front>
    <title abbrev="draft-rundgren-signed-http-requests">
      Signed HTTP Requests (SHREQ)
    </title>

    <author fullname="Anders Rundgren" initials="A." surname="Rundgren">
      <organization>Independent</organization>
      <address>
        <postal>
          <street></street>
          <code></code>
          <city>Montpellier</city>
          <country>France</country>
        </postal>
        <email>anders.rundgren.net@gmail.com</email>
        <uri>https://www.linkedin.com/in/andersrundgren/</uri>
      </address>
    </author>

    <date year="2019" />

    <area>Security</area>

    <workgroup></workgroup>

    <keyword>
      HTTP, URI, REST, JSON, JWS, Canonicalization, Signatures, Digests
    </keyword>

    <abstract>
      <t>
        The SHREQ specification describes how the JSON Web Signature (JWS)
        specification combined with the JSON Canonicalization Scheme (JCS),
        can be utilized to support HTTP based applications needing digitally signed requests.
        SHREQ is specifically tailored for Web applications using JSON as data interchange format.
        However, there is also a SHREQ scheme for HTTP requests that do not have a body ("payload") like GET.
        SHREQ was designed to be agnostic with respect to REST concepts versus traditional GET/POST schemes.
      </t>
      <t>
        The intended audiences of this document are Web tool vendors, as
        well as designers of secure Web applications.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
      <t>
        Currently there is no standard for digitally signing HTTP <xref target="RFC7231"/>
        requests.  This has lead to the development of a multitude
        of more or less proprietary solutions (see <xref target="other.solutions"/>),
        typically building on using HTTP header data for holding security constructs,
        while JSON request data is provided in clear in the HTTP body.
      </t>
      <t>
        SHREQ is intended to provide a standardized alternative, including supporting
        the REST <xref target="REST"/> concept.
      </t>
      <t>
        SHREQ builds on a common security model where all elements of an HTTP request are signed:
        <list style="symbols">
          <t>
            HTTP URI.
          </t>
          <t>
            HTTP method.
          </t>
          <t>
            HTTP body (if applicable).
          </t>
          <t>
            Optional: Additional HTTP headers as defined by the actual ecosystem.
          </t>
        </list>
        In addition there is a mandatory time stamp.
      </t>
       <t>
        One of the design goals was turning signed requests into self-contained objects.
        To achieve this for HTTP requests having a JSON <xref target="RFC8259"/> body
        (see <xref target="req.operation.withbody"/>), the request data also carries the signature.
        This arrangement has certain implications:
        <list style="symbols">
          <t>
            Signed requests may be stored in databases or be embedded in other JSON objects.
            The latter includes supporting counter signatures.  The canonicalization
            offered by JCS <xref target="JCS"/> enables validating the integrity of request data at any time.
          </t>
          <t>
            For general interoperability concerns as well as due to the reliance on JCS,
            JSON request data is limited to the I&nbhy;JSON <xref target="RFC7493"/> subset.
          </t>
        </list>
      </t>
      <t>
        For HTTP requests that do not have a JSON body (see <xref target="req.operation.urionly"/>), the
        signature and additional request data is added the URI <xref target="RFC3986"/> itself,
        making such requests self-contained and serializable as well.
      </t>
      <t>
        Both variants utilize JWS <xref target="RFC7515"/> for holding the signature data.
      </t>
      <t>
        For supporting signed HTTP responses any solution may be used.  For maximum "symmetry"
        and code reuse, the <xref target="JWSJCS"/> scheme should be a suitable candidate
        since it builds on the same building blocks as SHREQ.
      </t>
    </section>

    <section anchor="Terminology" title="Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>

    <section anchor="req.processing" title="HTTP Processing">
      <t>
        The following subsections describe HTTP specifics associated with this specification.
      </t>
      <section anchor="req.determine.type" title="Determining Request Type">
        <t>
          In this specification the distinction between HTTP requests having
          a JSON body or not is based on the presence of a "Content-Length" header.
          Requests without a body object are in this specification referred
          to as URI based requests.
        </t>
        <t>
          This also implies that not all header combinations permitted by HTTP can
          be used with this specification:
          <list style="hanging">
            <t hangText="&quot;Content-Length&quot;">
              <vspace blankLines="0"/>
              MUST NOT be used with URI based requests.  MUST be present for requests having a body
              and have an argument holding the length of the body in bytes.
            </t>
            <t hangText="&quot;Content-Type&quot;">
              <vspace blankLines="0"/>
              MUST NOT be used with URI based requests.  MUST be present for requests having a body
              and have the argument "application/json".
            </t>
            <t hangText="&quot;Content-Encoding&quot;">
              <vspace blankLines="0"/>
              MUST NOT be used with any requests targeting this specification.
            </t>
            <t hangText="&quot;Transfer-Encoding&quot;">
              <vspace blankLines="0"/>
              MUST NOT be used with any requests targeting this specification.
            </t>
          </list>
        </t>
      </section>
      <section anchor="return.codes" title="Return Codes">
        <t>
          This specification utilizes a single HTTP return code 400 (Bad request)
          for indicating syntax or security errors.  Since the number of possible
          error conditions is significant, it is RECOMMENDED to accompany
          the error code with a short explanation in "text/plain" format in the HTTP Body like:
        </t>
        <t>
          <figure align="left"><artwork><![CDATA[  - Missing ".secinf" element
  - Invalid "alg": es256
  - Unknown "kid": example.com:rsa:2018.1
  - com.example.jose.Core.validate(2653): Signature validation error
  - Missing header variable "x-testing"]]></artwork></figure>
        </t>
        <t>
          Communities using this specification MAY customize error codes if needed.
          However, in practice, it usually turns out to be of little value
          compared to a text message and a generic "hard&nbsp;error" code since
          neither users nor machines can do very much on their own
          to fix errors that are outside of normal processing.
        </t>
        <t>
          Application level errors are dealt with in an application specific manner.
          As an example a bank application which finds out that the customer do not have
          enough funds to perform a transaction would presumably not return
          an HTTP error code but rather a specifically crafted error message
          to be displayed to the user.
        </t>
        <t>
          Return codes for successful operation is application specific but are
          typically 200 (OK) or 201 (Created).
        </t>
      </section>
    </section>

    <section anchor="req.operation.withbody" title="Processing of JSON Based Requests">
      <t>
        Assume there is an unsigned HTTP request like the following:
      </t>
      <t>
        <figure align="left"><artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/json
  Content-Length: 1234

  {
    "something": "data",

         Additional application specific properties

  }]]></artwork></figure>
      </t>
      <t>
        Adding a signature to the request above would require the following enhancements to the JSON payload:
      </t>
      <t>
        <figure align="left"><artwork><![CDATA[  {
    "something": "data",

         Additional application specific properties

    ".secinf": {
      "uri": "https://example.com/transact/pay",
      "mtd": "POST",
      "iat": 1551709923,
      "jws": "eyJhbGciOiJIUzI1NiJ9..VHVItCBCb849imarDtjw4"
    }
  }]]></artwork></figure>
      </t>
      <t>
        Notes:
        <list style="symbols">
          <t>
            This specification presumes that request data is expressed as a JSON Object.
          </t>
          <t>
            The "uri" property holds a normalized target URI.
          </t>
          <t>
            The "mtd" property holds the expected HTTP method. In the example it is actually
            redundant since the absence of a "mtd" property defaults to "POST" for JSON based requests
            in this specification.
          </t>
          <t>
            The "iat" property holds the time stamp in UNIX "epoch" format.
          </t>
          <t>
            The argument to "jws" (a detached compact JWS) was truncated for brevity.
          </t> 
        </list>
      </t>
      <t>
        The following subsections detail the operation for requests having an HTTP body.
      </t>
      <section anchor="req.creation.withbody" title="Request Creation">
        <t>
          Precondition: the application data to be submitted with the request already exists in
          a format serializable as a JSON Object, from now on referred to as "message".
        </t>
        <t>
          In order to create a valid signed JSON request, the following steps (and ordering)
          MUST be adhered to:
          <list style="numbers">
            <t>
              Store the target HTTP method in a variable "targetMethod".
            </t>
            <t>
              Store the target URI in a variable "targetURI" after having normalized it as described in <xref target="normalize.uri"/>.
            </t>
            <t>
              Add a JSON Object called ".secinf" to "message".
            </t>
            <t>
              Add a property "uri" to ".secinf" where the argument is a JSON String holding a copy of "targetURI".
            </t>
            <t>
              Add a property "mtd" to ".secinf" where the argument is a JSON String holding a copy of "targetMethod".
              <vspace blankLines="1"/>
              Note: for the HTTP method "POST", this step is optional because "POST" is the default
              for JSON based requests.
            </t>
            <t>
              If there is a need to include additional HTTP headers in the signed request data,
              perform the following steps:
              <list style="symbols">
                <t>
                  Derive (or define) the hash algorithm to use as described in <xref target="hash.algorithms"/>.
                  Save the algorithm in a variable "hashAlgorithm".
                </t>
                <t>
                  Create a header object as described in <xref target="header.creation"/>.
                </t>
                <t>
                  Add a property "hdr" to ".secinf" where the argument
                  is the JSON Object created in the preceding step.
                </t>
              </list>
            </t>
            <t>
              Add a time stamp property (see <xref target="time.stamps"/>) to ".secinf".
              <vspace blankLines="1"/>
              Note: if the application data already contains a suitable time stamp
              property, this step MAY be excluded.
            </t>
            <t>
              Create a "JWS&nbsp;Payload" <xref target="RFC7515"/> as described in <xref target="signable.json"/>.
            </t>
            <t>
              Create a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/> as described in <xref target="create.jwsprotheader"/>.
            </t>
            <t>
              Create a JWS string object as described in <xref target="create.signature"/>.
            </t>
            <t>
              Add a property "jws" to ".secinf" where the argument
              is a JSON String holding the result of the preceding step.
            </t>
            <t>
              Serialize "message" into an UTF-8 encoded byte array called "requestData".
            </t>
            <t>
              Submit an HTTP <xref target="RFC7231"/> compliant request to the "targetURI" including the following information:
              <list style="symbols">
                <t>
                  HTTP method set to "targetMethod".
                </t>
                <t>
                  HTTP Header "Content-Length" with the argument set to the length of "requestData".
                </t>
                <t>
                  HTTP Header "Content-Type" with the argument set to "application/json".
                </t>
                <t>
                  All HTTP headers (if any) specified in step 7.
                </t>
                <t>
                  Other HTTP headers (if any) needed by the application.
                </t>
                <t>
                  An HTTP Body containing a copy of "requestData".
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      <section anchor="req.validation.withbody" title="Request Validation">
        <t>
          In order to validate a request the following steps MUST be performed:
          <list style="numbers">
            <t>
              Store the HTTP method of the request in a variable "targetMethod".
            </t>
            <t>
              Store the from the request recreated target URI in a variable "targetURI" after having normalized it as described in <xref target="normalize.uri"/>.
            </t>
            <t>
              If the HTTP header "Content-Type" is missing or differs from "application/json"
              the service MUST reject the request (see <xref target="return.codes"/>).
            </t>
            <t>
              If the HTTP header "Content-Length" is missing or malformed
              the service MUST reject the request (see <xref target="return.codes"/>).
              Save the length data.
            </t>
            <t>
              Read HTTP body data into a byte array with the length retrieved in the preceding step.
            </t>
            <t>
              Parse the byte array created in the preceding step with a JSON parser and return the result
              in an object from now on referred to as "message".
              If there are parsing errors or if "message" is not a JSON Object
              the service MUST reject the request (see <xref target="return.codes"/>).
            </t>
            <t>
              Using "message", retrieve a JSON Object called ".secinf".
              If ".secinf" is missing or is not a JSON Object the service MUST reject the request (see <xref target="return.codes"/>).
            </t>
            <t>
              Using ".secinf", the property "jws" is read.
              If "jws" is missing or is not a JSON String the service MUST reject the request (see <xref target="return.codes"/>).
              Decode the read string as described in <xref target="jws.string.decoding"/>.
            </t>
            <t>
              Using ".secinf", the property "uri" is read.
              If "uri" is missing or does not match "targetURI" or is not a JSON String the service MUST
              reject the request (see <xref target="return.codes"/>).
              <vspace blankLines="1"/>
              Note: in some proxy arrangements it may be difficult retrieving the proper value of "targetURI".
              In such cases the comparison with "uri" MAY be disabled.
            </t>
            <t>
              Using ".secinf", the property "mtd" is read.
              if "mtd" is missing the HTTP method is assumed to be "POST" else it is assumed to be the read value.
              If the derived method does not match "targetMethod" or is not a JSON String the service MUST
              reject the request (see <xref target="return.codes"/>).
            </t>
            <t>
              If the optional "hdr" property is present in ".secinf" perform the following steps:
              <list style="symbols">
                <t>
                  Derive the hash algorithm to use as described in <xref target="hash.algorithms"/>.
                  Save the algorithm in a variable "hashAlgorithm".
                </t>
                <t>
                  Process the argument of "hdr" as described in <xref target="validate.header"/>.
                </t>
              </list>
            </t>
            <t>
              Using ".secinf", the property "iat" (see <xref target="time.stamps"/>) is read.
              if "iat" is missing or is not a JSON Number the service MUST
              reject the request (see <xref target="return.codes"/>).
              <vspace blankLines="1"/>
              Note: if the application data already contains a suitable time stamp
              property, this step MAY be excluded.
            </t>
            <t>
              Remove the "jws" property from ".secinf".
            </t>
            <t>
              Create a "JWS&nbsp;Payload" <xref target="RFC7515"/> as described in <xref target="signable.json"/>.
            </t>
            <t>
              Perform signature validation as described in <xref target="validate.signature"/>.
            </t>
          </list>
          Note: validation of application specific data can be performed anytime after step 6.
          The action(s) to perform after a possible failure is out of scope for this specification
          (see <xref target="return.codes"/>).
        </t>
      </section>
    </section>

    <section anchor="req.operation.urionly" title="Processing of URI Based Requests">
      <t>
        In this specification requests without an HTTP body are referred to
        as URI based requests. Also see <xref target="req.determine.type"/>.
      </t>
      <t>
        Assume there is an unsigned HTTP request like the following:
      </t>
      <t>
        <figure align="left"><artwork><![CDATA[  GET /lookup?id=435 HTTP/1.1
  Host: example.com]]></artwork></figure>
      </t>
      <t>
        The full URI would be as follows:
        <list style="empty">
          <t>
            https://example.com/lookup?id=435
          </t>
        </list>
      </t>
      <t>
        Adding a signature to this request according to this specfication
        would return the following URI:
        <list style="empty">
          <t>
            https://example.com/lookup?id=435&amp;.jws=eyJhhiJ.eyJ7fgw.VHVIt
          </t>
        </list>
      </t>
      <t>
        Notes:
        <list style="symbols">
          <t>
            The revised URI represents a complete serializable signed request object.
          </t>
          <t>
            The argument to ".jws" (a standard compact JWS) was truncated for brevity.
          </t>
        </list>
      </t>
      <t>
        The middle component of the JWS string ("JWS Payload"),
        contains Base64Url encoded signed data related to the request. It should
        (after Base64Url decoding) yield a JSON Object like the following:
      </t>
      <t>
        <figure align="left"><artwork><![CDATA[  {
    "htu": "tzIRr4Qi1uWBnuIhbEie9-MYY94FCKgPFN4BmXtoCCE",
    "mtd": "GET",
    "iat": 1551863696
  }]]></artwork></figure>
      </t>
      <t>
        Notes:
        <list style="symbols">
          <t>
            The property "htu" holds the Base64Url encoded value of the normalized
            target URI after it has been hashed by the hash algorithm associated with the JWS signature.
          </t>
          <t>
            The "mtd" property holds the expected HTTP method. In the example it is actually
            redundant since the absence of a "mtd" property defaults to "GET" for URI based requests
            in this specification.
          </t>
          <t>
            The "iat" property holds the time stamp in UNIX "epoch" format.
          </t>
        </list>
      </t>
      <t>
        The following subsections detail the operation for requests using an HTTP query string
        component for holding a signature.
      </t>
      <section anchor="req.creation.urionly" title="Request Creation">
        <t>
          In order to create a valid signed URI request, the following steps
          (and ordering) MUST be adhered to:
          <list style="numbers">
            <t>
              Store the target HTTP method in a variable "targetMethod".
            </t>
            <t>
              Store the target URI in a variable "targetURI" after having normalized it as described in <xref target="normalize.uri"/>.
            </t>
            <t>
              Create an empty JSON Object from now on referred to as ".secinf".
            </t>
            <t>
              Derive (or define) the hash algorithm to use as described in <xref target="hash.algorithms"/>.
              Save the algorithm in a variable "hashAlgorithm".
            </t>
            <t>
              Add a property "htu" (Hashed Target URI) to ".secinf" where the argument is a JSON String
              holding the outcome of the process described in <xref target="signable.uri"/>.
            </t>
            <t>
              Add a property "mtd" to ".secinf" where the argument is a JSON String holding a copy of "targetMethod".
              <vspace blankLines="1"/>
              Note: for the HTTP method "GET", this step is optional because "GET" is the default
              for URI based requests.
            </t>
            <t>
              If there is a need to include additional HTTP headers in the signed request data,
              perform the following steps:
              <list style="symbols">
                <t>
                  Create a header object as described in <xref target="header.creation"/>.
                </t>
                <t>
                  Add a property "hdr" to ".secinf" where the argument
                  is the JSON Object created in the preceding step.
                </t>
              </list>
            </t>
            <t>
              Add a time stamp property (see <xref target="time.stamps"/>) to ".secinf".
            </t>
            <t>
              Serialize the ".secinf" JSON Object into a UTF-8 byte array 
              representing a "JWS&nbsp;Payload" <xref target="RFC7515"/>.
            </t>
            <t>
              Create a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/> 
              as described in <xref target="create.jwsprotheader"/>.
            </t>
            <t>
              Create a JWS string object as described in <xref target="create.signature"/>.
            </t>
            <t>
              Create a query string component by concatenating ".jws=" with the JWS string created in the preceding step.
              This component is appended to the original unsigned request URI prepended by
              &amp; or ? depending on if it is the only query component or not.
            </t>
            <t>
              Submit an HTTP <xref target="RFC7231"/> compliant request to the target URI including the following information:
              <list style="symbols">
                <t>
                  HTTP method set to "targetMethod".
                </t>
                <t>
                  All HTTP headers (if any) specified in step 7.
                </t>
                <t>
                  Other HTTP headers (if any) needed by the application.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      <section anchor="req.validation.urionly" title="Request Validation">
        <t>
          In addition to normal validation of received data (which may be carried out
          before or after the steps outlined here),
          the following steps MUST be performed in order to validate a URI based HTTP request:
          <list style="numbers">
            <t>
              Store the HTTP method of the request in a variable "targetMethod".
            </t>
            <t>
              Store the from the request recreated target URI in a variable "targetURI" after having normalized it as described in <xref target="normalize.uri"/>.
            </t>
            <t>
              Extract the JWS string from the ".jws" element which MUST reside in the query string of "targetURI".
              If the JWS string is missing the service MUST
              reject the request (see <xref target="return.codes"/>).
            </t>
            <t>
              Decode the argument of the preceding step as described in <xref target="jws.string.decoding"/>.
            </t>
            <t>
              Remove the ".jws" query string component from "targetURI".
              Note that if the ".jws" query component is the last part of "targetURI", the
              delimiter immediately preceding the ".jws" component is removed,
              else the succeeding delimiter is removed.
            </t>
            <t>
              Parse "JWS&nbsp;Payload" (created in step 4) with a JSON parser
              and from now on refer to the result as ".secinf".
              If ".secinf" is not a JSON Object the service MUST
              reject the request (see <xref target="return.codes"/>).
            </t>
            <t>
              Derive the hash algorithm to use as described in <xref target="hash.algorithms"/>.
              Save the algorithm in a variable "hashAlgorithm".
            </t>
            <t>
              Using ".secinf" the property "htu" is read.
              If "htu" is missing or is not a JSON String the service MUST
              reject the request (see <xref target="return.codes"/>).
            </t>
            <t>
              Perform the operation described in <xref target="signable.uri"/> and compare the
              outcome with the argument to "htu".  If these value do not match the service MUST
              reject the request (see <xref target="return.codes"/>).
              <vspace blankLines="1"/>
              Note: in some proxy arrangements it may be difficult retrieving the proper value of "targetURI".
              In such cases the comparison with "htu" MAY be disabled.
            </t>
            <t>
              Using ".secinf", the property "mtd" is read.
              if "mtd" is missing the HTTP method is assumed to be "GET" else it is assumed to be the read value.
              If the derived method does not match "targetMethod" or is not a JSON String the service MUST
              reject the request (see <xref target="return.codes"/>).
            </t>
            <t>
              If the optional "hdr" property is present in ".secinf" perform the following step:
              <list style="symbols">
                <t>
                  Process the argument of "hdr" as described in <xref target="validate.header"/>.
                </t>
              </list>
            </t>
            <t>
              Using ".secinf", the property "iat" (see <xref target="time.stamps"/>) is read.
              if "iat" is missing or is not a JSON Number the service MUST
              reject the request (see <xref target="return.codes"/>).
            </t>
            <t>
              Perform signature validation as described in <xref target="validate.signature"/>.
            </t>
          </list>
          Note: validation of application specific data can be performed anytime.
          The action(s) to perform after a possible failure is out of scope for this specification
          (see <xref target="return.codes"/>).
        </t>
      </section>
    </section>

    <section anchor="common.ops" title="Common Operations">
      <t>
        SHREQ is a modular system using shared procedures described
        in the following subsections.
      </t>
      <section anchor="signable.json" title="Create Signable JSON Data">
        <t>
          Unsigned request data is now supposed to reside in "message".
          To facilitate resilience against (legitimate) variances in JSON processing
          between different platforms and systems,
          "message" needs to be canonicalized and serialized into a UTF-8 encoded byte array.
          If the used JSON tools offer intrinsic support for JCS <xref target="JCS"/>, this is
          typically a single operation, else the followings steps are performed:
          <list style="numbers">
            <t>
              Serialize "message" using standard JSON tools for the platform.
            </t>
            <t>
              Create a canonical and UTF-8 encoded form of the data created in the preceding step,
              through an external software solution supporting JCS.
            </t>
          </list>
          The output from JCS now represents a "JWS&nbsp;Payload" <xref target="RFC7515"/>.
        </t>
      </section>
      <section anchor="signable.uri" title="Create Signable URI Data">
        <t>
          For URI based requests, the steps to create signable URI data are as follows:
          <list style="numbers">
            <t>
              The signable URI data consists of the "targetMethod" and the
              "targetURI", separated by a comma character.  Applied to the sample in
              <xref target="req.operation.urionly"/> that would yield the following string:
              <list style="empty">
                <t>
                  GET,https://example.com/lookup?id=435
                </t>
              </list>
            </t>
            <t>
              The resulting string is subsequently converted to UTF-8 <xref target="UNICODE"/> which
              applied to the sample would yield the following byte array, here displayed
              in hexadecimal notation:
              <list style="empty">
                <t>
                  47 45 54 2c 68 74 74 70 73 3a 2f 2f 65 78 61 6d 70 6c 65 2e 63 6f
                  6d 2f 6c 6f 6f 6b 75 70 3f 69 64 3d 34 33 35
                </t>
              </list>
            </t>
          </list>
          The output from the last step is assigned to a "JWS&nbsp;Payload" <xref target="RFC7515"/> object.
        </t>
      </section>
      <section anchor="header.creation" title="Create HTTP Header Digest">
        <t>
          [[
          <list style="empty">
            <t>
              To be written...
            </t>
          </list>
          ]]
        </t>
      </section>
      <section anchor="create.jwsprotheader" title="Create JWS Protected Header">
        <t>
          Create a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/>
          JSON Object with algorithm and key data adapted for the application.
          Below is a minimal example:
        </t>
        <t>
          <figure align="left"><artwork><![CDATA[  {
    "alg": "ES256"
  }]]></artwork></figure>
        </t>
      </section>
      <section anchor="create.signature" title="Create JWS String">
        <t>
          To create a compact JWS object (a string), perform the following steps:
          <list style="numbers">
            <t>
              Serialize the previously defined "JWS&nbsp;Protected&nbsp;Header" object into a UTF-8 encoded byte array.
            </t>
            <t>
              Base64Url-encode the output from the preceding step into a local variable "jwsProtectedHeaderB64U".
            </t>
            <t>
              Base64Url-encode the previously defined variable "JWS&nbsp;Payload" into a local variable "jwsPayloadB64U".
            </t>
            <t>
              Set a local variable "signedData" to the UTF-8 encoded representation of the
              concatenation of:
              <list style="empty">
                <t>
                  The previously defined variable "jwsProtectedHeaderB64U".
                </t>
                <t>
                  A point character (".").
                </t>
                <t>
                  The previously defined variable "jwsPayloadB64U".
                </t>
              </list>
            </t>
            <t>
              Use the designated signature key, signature algorithm and
              "signedData" to create a "JWS&nbsp;Signature" object (byte array).
            </t>
            <t>
              Return the string consisting of the concatenation of:
              <list style="empty">
                <t>
                  The previously defined variable "jwsProtectedHeaderB64U".
                </t>
                <t>
                  A point character (".").
                </t>
                <t>
                  For URI based requests only: "jwsPayloadB64U".  That is, JSON based
                  requests use the detached JWS format described in Appendix F of <xref target="RFC7515"/>.
                </t>
                <t>
                  A point character (".").
                </t>
                <t>
                  The previously defined variable "JWS&nbsp;Signature",
                  here encoded in Base64Url <xref target="RFC4648"/>.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      <section anchor="jws.string.decoding" title="Decode JWS String">
        <t>
          The following processing steps presume that there is an input string holding
          a JWS compact object, here called "jwsString":
          <list style="numbers">
            <t>
              Verify that "jwsString" has the syntax
              <list style="empty">
                <t>
                  "header.payload.signature"
                </t>
              </list>
              where the length of the "payload" element is zero for JSON based requests and
              non-zero for URI based requests. That is, JSON based
              requests use the detached JWS format described in Appendix F of <xref target="RFC7515"/>.
            </t>
            <t>
              Assign the "header" portion of "jwsString" to a variable "jwsProtectedHeaderB64U".
            </t>
            <t>
              Base64Url-decode "jwsProtectedHeaderB64U" into a byte array.
            </t>
            <t>
              Parse the output from the preceding step with a JSON parser and
              assume that the result (which MUST be a JSON Object)
              represents a "JWS&nbsp;Protected&nbsp;Header" <xref target="RFC7515"/>.
            </t>
            <t>
              For URI based requests only:
              <vspace blankLines="0"/>
              base64Url-decode the "payload" portion of "jwsString" into a byte array
              representing a "JWS&nbsp;Payload" <xref target="RFC7515"/>. 
            </t>
            <t>
              Base64Url-decode the "signature" portion of "jwsString" into a byte array
              representing a "JWS&nbsp;Signature" <xref target="RFC7515"/>.
            </t>
          </list>
          If any of the steps fails, the service MUST reject the request (see <xref target="return.codes"/>).
        </t>
      </section>
      <section anchor="normalize.uri" title="Normalize Target URI">
        <t>
          [[
          <list style="empty">
            <t>
              To be written...
            </t>
          </list>
          ]]
        </t>
      </section>
      <section anchor="validate.header" title="Validate HTTP Header Digest">
        <t>
          [[
          <list style="empty">
            <t>
              To be written...
            </t>
          </list>
          ]]
        </t>
      </section>
      <section anchor="validate.signature" title="Validate Signature">
        <t>
          Validation of the JWS <xref target="RFC7515"/> object,
          using the previously extracted and decoded objects requires the following steps:
          <list style="numbers">
            <t>
              Verify that the received "JWS&nbsp;Protected&nbsp;Header" contains
              a JWS algorithm ("alg") and key identifiers that
              matches the needs of the application.
            </t>
            <t>
              Retrieve the signature validation key. This part is application specific since
              the key may be implicit, specified by a key ID ("kid") or be supplied
              in a certificate path ("x5c").
            </t>
            <t>
              Set a local variable "signedData" to the UTF-8 encoded representation of the
              string created by concatenating the following elements:
              <list style="empty">
                <t>
                  The previously collected variable "jwsProtectedHeaderB64U".
                </t>
                <t>
                  A point character (".").
                </t>
                <t>
                  The previously collected variable "JWS Payload",
                  but here encoded in Base64Url <xref target="RFC4648"/>.
                </t>
              </list>
            </t>
            <t>
              Validate the signature using the algorithm retrieved in step 1,
              the signature validation key from step 2,
              "signedData" from step 3 and the previously collected "JWS&nbsp;Signature" object (byte array). 
            </t>
          </list>
          If any of the steps fails, the service MUST reject the request (see <xref target="return.codes"/>).
        </t>
      </section>
      <section anchor="time.stamps" title="Time Stamps">
        <t>
          Time stamps have the same name ("iat"), format and function as described in Section 4.1.6 of <xref target="RFC7519"/>.
          However, in this specification time stamps are REQUIRED, and stored in the ".secinf" JSON Object.
        </t>
        <t>
          The policy with respect to the difference between the current time and received time stamps
          is out of scope for this specification.  However, for security reasons it is
          generally a good idea limiting deviations to a few minutes as well as using
          network based clock synchronization in both ends.
        </t>
      </section>
      <section anchor="hash.algorithms" title="Hash Algorithms">
        <t>
          Inclusion of HTTP header elements as well as the "htu" property of URI based
          requests depends on digests produced by a hash algorithm.  The default is
          using the hash algorithm associated with the JWS signature algorithm ("alg")
          featured in the "JWS&nbsp;Protected&nbsp;Header".
          That is, "ES256" and "HS384" imply the hash algorithms SHA256 and SHA384 respectively.
        </t>
        <t>
          In case this is not desired, this specification permits overriding the default
          by including a "hao" (Hash Algorithm Override) property in the ".secinf" JSON Object.
          The currently recognized arguments to "hao" are:
          <list style="empty">
            <t>
              "S256" for SHA256 <xref target="SHS"/>
            </t>
            <t>
              "S384" for SHA384 <xref target="SHS"/>
            </t>
            <t>
              "S512" for SHA512 <xref target="SHS"/>
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="overriding" title="Local Naming Conventions">
      <t>
        Although the ".secinf" JSON property name and
        ".jws" query component name are highly RECOMMENDED,
        this specfication permits (=being considered as compatible),
        the use of local naming conventions as long as the
        specified procedures and formats are adhered to.
      </t>
      <t>
        Local naming conventions MUST be properly communicated in
        the community using them.
      </t>
    </section>
 
    <section anchor="mime.mulipart" title="MIME Multipart Requests">
      <t>
        [[
        <list style="empty">
          <t>
            It should be possible to extending the JSON based request
            to also support attachments.  This is currently out of scope
            for this specification.
          </t>
        </list>
        ]]
      </t>
    </section>
 
    <section anchor="IANA" title="IANA Considerations">
      <t>
        This document currently has no IANA actions but the reserved names
        below could be candidates for IANA registration:
        <list style="hanging">
          <t hangText=".secinf">
            &nbsp;
            <vspace blankLines="0"/>
            JSON property holding the security related data of this specification.
          </t>
          <t hangText=".jws">
            &nbsp;
            <vspace blankLines="0"/>
            HTTP query component holding the security related data of this specification.
          </t>
        </list>
      </t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
        The purpose of this specification is adding an integrity
        and authorization layer to HTTP requests.  This part is subject
        to the same security considerations as the underpinning
        JCS and JWS schemes.
      </t>
      <t>
        For most applications HTTPS <xref target="RFC7231"/> would be the logical choice, not
        only for protecting application data from snooping, but
        also to not unessecary reveal data about signature keys.
      </t>
      <t>
        In a cloud scenario with Web servers open for access by
        any party new security challenges are introduced.  Cryptographic
        solutions protect data but may also add vulnerabilities to
        denial-of-service attacks since they often need substantial
        processing.
      </t>
      <t>
        Protecting against replay attacks is important because replay
        may actually be a legitimate facility for systems repeating
        a request due to a communication failure.  This cannot be
        entirely solved by time stamps and cryptography; you usually
        need unique transactions IDs and data base support as well.
        For reliable operation there must be common rules within a
        community using such features.
        The REST <xref target="REST"/> paradigm also requires such
        measures due to the idempotent operation specified for
        "PUT", "GET" and "DELETE.
      </t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        Parts of this specification were derived from the HTTP signature <xref target="HTTPSIG"/> draft.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.3986'?>
      <?rfc include='reference.RFC.4648'?>
      <?rfc include='reference.RFC.8259'?>
      <?rfc include='reference.RFC.7515'?>
      <?rfc include='reference.RFC.7519'?>
      <?rfc include='reference.RFC.8174'?>
      <?rfc include='reference.RFC.7493'?>
      <?rfc include='reference.RFC.7231'?>
      <reference anchor="UNICODE" target="https://www.unicode.org/versions/Unicode10.0.0/">
        <front>
          <title>The Unicode Standard, Version 10.0.0</title>
          <author>
            <organization>The Unicode Consortium</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="SHS" target="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">
        <front>
          <title>Secure Hash Standard (SHS)</title>
          <author>
            <organization>
              National Institute of Standards and Technology
            </organization>
          </author>
          <date month="August" year="2015" />
        </front>
        <seriesInfo name="FIPS" value="PUB 180-4" />
      </reference>
      <reference anchor="JCS" target="https://tools.ietf.org/html/draft-rundgren-json-canonicalization-scheme-05">
        <front>
          <title>JSON Canonicalization Scheme - Work in progress</title>
          <author>
            <organization>A. Rundgren, B. Jordan, S. Erdtman</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="JWSJCS" target="https://github.com/cyberphone/jws-jcs">
        <front>
          <title>Combined JWS and JCS Signature Scheme - Work in progress</title>
          <author>
            <organization>A. Rundgren</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <references title="Informal References">
      <reference anchor="REST" target="http://roy.gbiv.com/pubs/dissertation/top.htm">
        <front>
          <title>Architectural Styles and the Design of Network-based Software Architectures</title>
          <author>
            <organization>Roy Fielding</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="HTTPSIG" target="https://tools.ietf.org/html/draft-cavage-http-signatures-10">
        <front>
          <title>Signing HTTP Messages</title>
          <author>
            <organization>M. Cavage, M. Sporny</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="OBIE" target="https://www.openbanking.org.uk/">
        <front>
          <title>Open Banking API</title>
          <author>
            <organization>Open Banking UK</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="AWS" target="https://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html">
        <front>
          <title>Signing AWS API Requests</title>
          <author>
            <organization>Amazon.com</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="FAPI" target="https://openid.net/wg/fapi/">
        <front>
          <title>Financial-grade API</title>
          <author>
            <organization>Open ID</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="STET" target="https://www.stet.eu/en/psd2/">
        <front>
          <title>PSD2 API V1.4.1</title>
          <author>
            <organization>STET</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>

    <section anchor="testing" title="Test Vectors">
      <t>
        [[
        <list style="empty">
          <t>
            To be supplied
          </t>
        </list>
        ]]
      </t>
    </section>
    
    <section anchor="other.solutions" title="Other Signed HTTP Request Solutions">
      <t>
        This appendix briefly outlines a few other solutions addressing
        Signed HTTP Requests.
      </t>
      <section anchor="other.aws" title="Amazon Web Services">
        <t>
          Amazon Web Sevices provides a system for their clients using
          HTTP headers holding security constructs while the
          digested HTTP body may hold any valid media type.
          For more information see the <xref target="AWS"/>.
          Signatures may also be added to query strings in a similar
          fashion to <xref target="req.operation.urionly"/>.
        </t>
      </section>
      <section anchor="other.httsignatures" title="HTTP Signatures">
        <t>
          HTTP Signatures is a system using
          HTTP headers holding security constructs while the (optional)
          digested HTTP body may hold any valid media type.
          This scheme has been adopted by the French Open Banking API <xref target="STET"/>.
          For more information see the Internet draft <xref target="HTTPSIG"/>.
          HTTP Signatures also supports signed response data.
        </t>
      </section>
      <section anchor="other.openbanking" title="Open Banking (UK)">
        <t>
          The current (3.1) version of the Open Banking API <xref target="OBIE"/>
          use a scheme where a dedicated HTTP header holds
          a detached JWS signature covering a clear text JSON
          message in the HTTP body:
          <figure align="left"><artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/json
  x-jws-signature: eyJhbGciOiJSUzI1N..SD7xMbpL-2QgwUsAlMGzw
  Content-Length: 2765

  {
     "something": "data",
 
         Additional application specific properties

  }]]></artwork></figure>
        </t>
        <t>
          Notes:
          <list style="symbols">
            <t>
              The HTTP URI, method and headers are unsigned.
            </t>
            <t>
              The signature argument (a JWS) was truncated for brevity.
            </t>
          </list>
        </t>
      </section>
      <section anchor="other.fapi" title="Financial API">
        <t>
          The current version (Draft 06) of the financial API <xref target="FAPI"/> use
          a scheme where the payload is signed using JWS in Base64Url <xref target="RFC4648"/> mode:
          <figure align="left"><artwork><![CDATA[  POST /transact/pay HTTP/1.1
  Host: example.com
  Content-Type: application/jws
  Content-Length: 1288

  eyJhbGcRjIn0.ew0KICJfds56gty5ypc3MiOiA.2QgwUsA565656lMGzw]]></artwork></figure>
        </t>
        <t>
          Notes:
          <list style="symbols">
            <t>
              The HTTP URI, method and headers are unsigned.
            </t>
            <t>
              The JWS signature was truncated for brevity.
            </t>
          </list>
        </t>
      </section>
    </section>
  
    <section anchor="shreq.development" title="Development Portal">
      <t>
        The SHREQ specification is currently developed at:
        <eref target="https://cyberphone.github.io/ietf-signed-http-requests">https://cyberphone.github.io/ietf-signed-http-requests</eref>.
      </t>
      <t>
        <vspace blankLines="3"/>
      </t>
    </section>
  
  </back>
</rfc>
